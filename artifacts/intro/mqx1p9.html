---
title: 隐语框架的分层拆解和使用
toc: content
dateModified: 2022-10-14T10:25:23.000Z
---
<!doctype html><div class="lake-content" typography="classic"><h2 id="DgRyg"><span class="ne-text">“隐语”架构设计全貌</span></h2><h3 id="lvY1b"><span class="ne-text">1.隐语框架设计思想</span></h3><p id="u1c747ede" class="ne-p" style="line-height: 1.5"><span class="ne-text">隐私计算是一个新兴的跨学科领域，涉及密码学、机器学习、数据库、硬件等多个领域。根据过去几年的实践经验，我们发现</span></p><ul class="ne-ul"><li id="u74de1abd" style="line-height: 1.5"><span class="ne-text">隐私计算技术方向多样，不同场景下有其各自更为合适的技术解决方案</span></li><li id="u3b22f52e" style="line-height: 1.5"><span class="ne-text">隐私计算学习曲线很高，非隐私计算背景的用户使用困难</span></li><li id="u4f0c7141" style="line-height: 1.5"><span class="ne-text">隐私计算涉及领域众多，需要领域专家共同协作</span></li></ul><p id="u04a4afd7" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u8f6646d4" class="ne-p" style="line-height: 1.5"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470047101-42bfd930-9838-435c-a49e-c8189e7f4b47.png" width="351" id="uc2533e20" class="ne-image"></p><p id="u2b36a5a8" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u109d0453" class="ne-p" style="line-height: 1.5"><span class="ne-text">隐语的设计目标是使得数据科学家和机器学习开发者可以非常容易地使用隐私计算技术进行数据分析和机器学习建模，而无需了解底层技术细节。 </span></p><p id="ud5f3a782" class="ne-p" style="line-height: 1.5"><span class="ne-text">为达到这个目标，隐语提供了一层设备抽象，将多方安全计算(MPC)、同态加密(HE)和可信执行环境(TEE)等隐私计算技术抽象为密文设备， 将单方计算抽象为明文设备。</span></p><p id="uf3ee57de" class="ne-p" style="line-height: 1.5"><span class="ne-text">基于这层抽象，数据分析和机器学习工作流可以表示为一张计算图，其中节点表示某个设备上的计算，边表示设备之间的数据流动，不同类型设备之间的数据流动会自动进行协议转换。在这一点上，隐语借鉴了主流的深度学习框架，后者将神经网络表示为一张由设备上的算子和设备间的张量流动构成的计算图。</span></p><p id="u6ba6591a" class="ne-p" style="line-height: 1.5"><span class="ne-text">隐语框架围绕开放这一核心思想，提供了不同层次的设计抽象，希望为不同类型的开发者都提供良好的开发体验。</span></p><p id="uc5b6acdd" class="ne-p" style="line-height: 1.5"><span class="ne-text">在设备层，隐语提供了良好的设备接口和协议接口，支持更多的设备和协议插拔式的接入，我们希望与密码学、可信硬件、硬件加速等领域专家通力合作，不断扩展密态计算的类型和功能，不断提升协议的安全性和计算性能。</span></p><p id="ueb8cdbd8" class="ne-p" style="line-height: 1.5"><span class="ne-text">同时，隐语提供了良好的设备接口，第三方隐私计算协议可作为设备插拔式接入。在算法层，为机器学习提供了灵活的编程接口，算法开发者可以很容易定义自己的算法。</span></p><p id="u2ae98569" class="ne-p"><span class="ne-text"></span></p><h3 id="LhTCy"><span class="ne-text">2.架构分层总览</span></h3><p id="u33aa8bc1" class="ne-p" style="line-height: 1.5"><span class="ne-text">隐语总体架构自底向上一共分为五层：</span></p><p id="ub7bb2c41" class="ne-p" style="line-height: 1.5"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470046210-a7a56fed-1fdb-411c-993e-6110d3d3abbb.png" width="983" id="u95dde4dc" class="ne-image"></p><p id="u6900209f" class="ne-p"><strong><span class="ne-text">资源管理层：</span></strong><span class="ne-text">主要承担了两方面的职责。第一是面向业务交付团队，可以屏蔽不同机构底层基础设施的差异，降低业务交付团队的部署运维成本。另一方面，通过对不同机构的资源进行集中式管理，构建出一个高效协作的数据协同网络。</span></p><p id="u2577a6d6" class="ne-p"><strong><span class="ne-text">明密文计算设备与原语层：</span></strong><span class="ne-text">提供了统一的可编程设备抽象，将多方安全计算(MPC)、同态加密(HE)、可信硬件(TEE)等隐私计算技术抽象为密态设备，将单方本地计算抽象为明文设备。同时，提供了一些不适合作为设备抽象的基础算法，如差分隐私(DP)、安全聚合(Secure Aggregation)等。</span></p><p id="ud24910b7" class="ne-p"><strong><span class="ne-text">明密文混合调度层：</span></strong><span class="ne-text">提供了统一的设备调度抽象，将上层算法描述为一张有向无环图，其中节点表示某个设备上的计算，边表示设备之间的数据流动，即逻辑计算图。逻辑计算图由分布式框架进一步拆分并调度至物理节点。</span></p><p id="udca8ae1e" class="ne-p"><strong><span class="ne-text">AI &amp; BI 隐私算法层：</span></strong><span class="ne-text">这一层的目的是屏蔽掉隐私计算技术细节，但保留隐私计算的概念，其目的是降低隐私计算算法的开发门槛，提升开发效率。有隐私计算算法开发诉求的同学，可以根据自身场景和业务的特点，设计出一些特化的隐私计算算法，来满足自身业务和场景对安全性、计算性能和计算精度的平衡。在这一层上，隐语本身也会提供一些通用的算法能力，比如MPC的LR/XGB/NN，联邦学习算法，SQL能力等。</span></p><p id="u6d9fe243" class="ne-p"><strong><span class="ne-text">用户界面层：</span></strong><span class="ne-text">隐语的目标并不是做一个端到端的产品，而是为了让不同的业务都能够通过快速集成隐语而具备全面的隐私计算能力。因此我们会在最上层去提供一层比较薄的产品API，以及一些SDK，去降低业务方集成隐语的成本。</span></p><p id="u42c3a568" class="ne-p"><br></p><h3 id="X9h2r"><span class="ne-text">3.架构细节拆解</span></h3><h4 id="fMIQW"><span class="ne-text">设备与原语层</span></h4><p id="u92856f0c" class="ne-p" style="line-height: 1.5"><span class="ne-text">隐语的设备分为物理设备和逻辑设备，其中，物理设备是隐私计算各个参与方的物理机器，逻辑设备则由一个或多个物理设备构成。逻辑设备支持一组 特定的计算算子(Device Ops)，有自己特定的数据表示(Device Object)<br /></span><span class="ne-text">。逻辑设备分为明文和密文两种类型，前者执行单方本地计算，后者执行 多方参与的隐私计算。</span></p><p id="uf84ad516" class="ne-p" style="line-height: 1.5"><span class="ne-text">逻辑设备的运行时负责内存管理、数据传输、算子调度等职责，运行在一个或多个物理设备上。逻辑设备和物理设备不是一对一的关系，一个物理设备 可能同时属于多个逻辑设备。在同一组物理设备上，可以根据不同的隐私协议和参与组合虚拟出不同的逻辑设备。</span></p><p id="u322bc8f4" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u9f73a49b" class="ne-p" style="line-height: 1.5"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470045619-bbc401b0-4252-425c-ba18-81494d00a306.png" width="536" id="ued2c358d" class="ne-image"></p><p id="u3dc30028" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u64ba7545" class="ne-p" style="line-height: 1.5"><span class="ne-text">下表是隐语目前暂定支持的设备列表：</span></p><table id="ghr6X" class="ne-table" style="width: 719px"><tbody><tr style="height: 33px"><td width="48"><p id="ufd4ac48c" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">设备</span></strong></p></td><td width="46"><p id="u5b822b05" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">类型</span></strong></p></td><td width="124"><p id="u0b8791b3" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">运行时</span></strong></p></td><td width="103"><p id="u22d49944" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">算子</span></strong></p></td><td width="118"><p id="u0e830827" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">协议</span></strong></p></td><td width="173"><p id="u2a31cd18" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">前端</span></strong></p></td><td width="107"><p id="u68747570" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">状态</span></strong></p></td></tr><tr style="height: 33px"><td width="48"><p id="u4c3d564c" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">PYU</span></strong></p></td><td width="46"><p id="ud59e759c" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">明文</span></p></td><td width="124"><p id="u52387769" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Python Interpreter</span></p></td><td width="103"><p id="u54eee930" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">—</span></p></td><td width="118"><p id="ud9151415" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">—</span></p></td><td width="173"><p id="ub07dda96" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Python</span></p></td><td width="107"><p id="u99d322ac" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Release</span></p></td></tr><tr style="height: 33px"><td width="48"><p id="ud6549ba3" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">SPU</span></strong></p></td><td width="46"><p id="u16caa43c" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">密文</span></p></td><td width="124"><p id="u45705b5f" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">SPU VM</span></p></td><td width="103"><p id="u8f4c5be4" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">PSI, XLA HLO</span></p></td><td width="118"><p id="uc10685fa" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">SPDZ-2k, ABY3</span></p></td><td width="173"><p id="uf0cd58cb" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">JAX, TensorFlow, PyTorch</span></p></td><td width="107"><p id="uf180f5b5" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Alpha</span></p></td></tr><tr style="height: 33px"><td width="48"><p id="ufef4b373" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">HEU</span></strong></p></td><td width="46"><p id="u9578129d" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">密文</span></p></td><td width="124"><p id="ub17eaede" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">HEU Runtime</span></p></td><td width="103"><p id="ub3fa74c7" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Add, XLA HLO</span></p></td><td width="118"><p id="u5083fec2" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Paillier, OU, TFHE</span></p></td><td width="173"><p id="uc462031b" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Numpy, JAX</span></p></td><td width="107"><p id="ucd57df30" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Alpha</span></p></td></tr><tr style="height: 33px"><td width="48"><p id="u74ddbc99" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 12px">TEE</span></strong></p></td><td width="46"><p id="u7d4abb62" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">密文</span></p></td><td width="124"><p id="u318cfa49" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">TEE Runtime</span></p></td><td width="103"><p id="ucfe25c64" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">XLA HLO</span></p></td><td width="118"><p id="u3ec9018d" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">Intel SGX</span></p></td><td width="173"><p id="u43517b1a" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">JAX, TensorFlow, PyTorch</span></p></td><td width="107"><p id="u87ad64ad" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 12px">WIP</span></p></td></tr></tbody></table><p id="u443fd7a5" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><h4 id="LHQDM"><span class="ne-text">可编程性</span></h4><p id="ub10ca185" class="ne-p" style="line-height: 1.5"><span class="ne-text">逻辑设备具备可编程性，即用户可以在设备上自定义计算逻辑，每个设备对用户提供了协议无关的编程接口。在一个设备上，用户可以定义从简单的矩阵运算， 到完整的深度模型训练。当然，这一切取决于设备提供的计算能力。</span></p><p id="u98812598" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="ufe879f44" class="ne-p" style="line-height: 1.5"><span class="ne-text">对于明文设备PYU，它的前端为python，用户可以通过</span><code class="ne-code"><span class="ne-text">@device</span></code><span class="ne-text">将一段预定义python函数调度至其上执行。</span></p><p id="u37cefce8" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="u067779fc" class="ne-p" style="line-height: 1.5"><span class="ne-text">对于密文设备SPU、HEU、TEE，它们的前端可以是任何支持</span><a href="https://www.tensorflow.org/xla/architecture" data-href="https://www.tensorflow.org/xla/architecture" target="_blank" class="ne-link"><span class="ne-text">XLA</span></a><span class="ne-text"> 的框架， 如JAX, TensorFlow,<br /></span><span class="ne-text">PyTorch等。同样的，用户也可以通过</span><code class="ne-code"><span class="ne-text">@device</span></code><span class="ne-text">将基于这些前端自定义的函数调度至指定的设备执行。</span></p><p id="u00f3794b" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><pre data-language="python" id="T9duv" class="ne-codeblock language-python">import jax.numpy as jnp

dev = Device()  # maybe PYU, SPU, HEU, TEE


@device(dev)
def selu(x, alpha=1.67, lmbda=1.05):
    return lmbda * jnp.where(x &gt; 0, x, alpha * jnp.exp(x) - alpha)


res = selu(x)  # res is a DeviceObject</pre><p id="ua713d160" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u2d3b90ce" class="ne-p" style="line-height: 1.5"><span class="ne-text">用户自定义函数首先转换成XLA HLO Computation，由XLA进行设备无关的代码优化和分析，并发往后端设备。后端设备进一步执行代码优化和分析，并生成最终 的可执行代码。可执行代码或由设备的虚拟机解释执行(SPU, HEU)<br /></span><span class="ne-text">，或由硬件直接执行(TEE)。使用XLA HLO作为IR，使得我们可以复用XLA前端和设备无关 代码优化，同时使得后端实现更加简洁干净。</span></p><p id="u7a502260" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="u17bc9974" class="ne-p" style="line-height: 1.5"><span class="ne-text">对于密文设备（半同态）HEU，它仅支持一组有限的计算，因此提供了一组预定义算子如</span><code class="ne-code"><span class="ne-text">__add__</span></code><span class="ne-text">, </span><code class="ne-code"><span class="ne-text">__mul__</span></code><span class="ne-text">等，用户不能通过</span><code class="ne-code"><span class="ne-text">@device</span></code><span class="ne-text">进行自定义编程。</span></p><p id="uda4e8da4" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><pre data-language="python" id="w5evY" class="ne-codeblock language-python">x, y = HEUObject(), PYUObject()
z = x + y  # add
z = x * y  # mul
z = x @ y  # matmul</pre><h4 id="L1jvE"><span class="ne-text">协议转换</span></h4><p id="u625e3fdd" class="ne-p" style="line-height: 1.5"><span class="ne-text">用户在逻辑设备上进行编程，构建逻辑计算图，其节点表示设备上的一段函数或算子，边表示设备对象的流动。逻辑计算图被设备进一步分割为子图，两个子图间的 边表示跨设备的对象流动，此时需要进行协议转换。设备对象的</span><code class="ne-code"><span class="ne-text">DeviceObject.to</span></code><span class="ne-text">接口用于转换至目标设备对象，任何新增的设备都应该提供相应的转换函数并 插入对象转换表中。</span></p><p id="u33268645" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="u072c6589" class="ne-p" style="line-height: 1.5"><span class="ne-text">下表是各个逻辑设备对象的转换表：</span></p><table id="509a0efe" class="ne-table" style="width: 646px"><tbody><tr style="height: 33px"><td width="72"><p id="u97a0a07f" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px"></span></p></td><td width="106"><p id="ucabdd301" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">PYU</span></strong></p></td><td width="150"><p id="u11ce290a" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">SPU</span></strong></p></td><td width="150"><p id="u4203ea8e" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">HEU</span></strong></p></td><td width="168"><p id="ufbc7bc31" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">TEE</span></strong></p></td></tr><tr style="height: 33px"><td width="72"><p id="u35ff891b" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">PYU</span></strong></p></td><td width="106"><p id="u1e1ecc51" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px"></span></p></td><td width="150"><p id="u671b5470" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">share</span></p></td><td width="150"><p id="u4b4f5499" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">encrypt</span></p></td><td width="168"><p id="ub903b43c" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">encrypt</span></p></td></tr><tr style="height: 33px"><td width="72"><p id="u9a9cea73" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">SPU</span></strong></p></td><td width="106"><p id="ud46d5d76" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">reconstruct</span></p></td><td width="150"><p id="u374eee98" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px"></span></p></td><td width="150"><p id="u8fb4ae4f" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">encrypt+add</span></p></td><td width="168"><p id="u2b58d01d" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">reconstruct+encrypt</span></p></td></tr><tr style="height: 33px"><td width="72"><p id="ud3a83b33" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">HEU</span></strong></p></td><td width="106"><p id="u4d215e20" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">decrypt</span></p></td><td width="150"><p id="u72f1d598" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">minus+decrypt</span></p></td><td width="150"><p id="u7d6f2735" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px"></span></p></td><td width="168"><p id="u035263db" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">decrypt+encrypt</span></p></td></tr><tr style="height: 33px"><td width="72"><p id="ud3ba052c" class="ne-p" style="line-height: 1.5"><strong><span class="ne-text" style="font-size: 14px">TEE</span></strong></p></td><td width="106"><p id="ua93aadfb" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">decrypt</span></p></td><td width="150"><p id="u111a8a3b" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">decrypt+share</span></p></td><td width="150"><p id="uf18eefaf" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px">decrypt+encrypt</span></p></td><td width="168"><p id="u82ff51d2" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="font-size: 14px"></span></p></td></tr></tbody></table><h4 id="W9BA6"><span class="ne-text">分布式引擎</span></h4><p id="u02d2fb7e" class="ne-p" style="line-height: 1.5"><span class="ne-text">用户基于设备构建了一张逻辑计算图，那么我们如何执行这张计算图？由于逻辑设备映射到一个或多个物理设备，因此我们需要将逻辑设备上的算子正确调度到其对应的物理设备，同时处理好这些物理设备间的数据传输关系。毫无疑问，我们需要一个分布式图执行引擎来解决这些问题。</span></p><p id="u3fc66f85" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="uff46348a" class="ne-p" style="line-height: 1.5"><span class="ne-text">那么我们需要一个怎样的分布式图执行引擎？以下是隐语对它的要求</span></p><ul class="ne-ul"><li id="ucbc25ece" style="line-height: 1.5"><span class="ne-text">细粒度的异构计算：在一张逻辑计算图中，具有不同粒度的计算任务，既有简单的数据处理（秒级），也有复杂的多方训练（几个小时至几十小时）。 同时，物理节点具有不同的硬件环境，CPU, GPU, TEE, FPGA等。</span></li><li id="ua6a45b0f" style="line-height: 1.5"><span class="ne-text">灵活的计算模型：在水平、垂直场景下，针对数据处理和模型训练等不同工作流，支持多种并行模型，如数据并行、模型并行、混合并行。</span></li><li id="uc9062631" style="line-height: 1.5"><span class="ne-text">动态执行：在联邦学习场景下，不同机构的数据规模、带宽延迟、机器性能可能有较大差异，这导致同步模式的效率受限于最慢的工作节点。因此，我们希望支持 异步训练模式，这要求图执行引擎具有动态执行能力。</span></li></ul><p id="u85f9a5e5" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u131839cc" class="ne-p" style="line-height: 1.5"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470046259-be7fc7ac-043a-4833-bdc9-d89f2c7407d2.png" width="615" id="ud0c068d3" class="ne-image"></p><p id="u7c260c8c" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u957ac914" class="ne-p"><span class="ne-text">隐语针对隐私计算场景，已经对框架进行了一些安全加固工作：通过身份认证、代码预装、代码存证等手段对框架做了整体加固。未来，还将探索沙箱隔离、访问控制、静态图等机制以进一步提升安全水位。在环境适配方面，为了适配跨机构网络通信的特点，推进了GCS gRPC通信、域名支持、弱网断线处理等相关功能的开发。</span></p><p id="ud3f424f7" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><h4 id="Hx8YO"><strong><span class="ne-text">AI &amp; BI 隐私算法</span></strong><span class="ne-text"></span></h4><p id="u829ee904" class="ne-p"><span class="ne-text">这一层的目的是屏蔽掉隐私计算技术细节，但保留隐私计算的概念，其目的是降低隐私计算算法的开发门槛，提升开发效率。有隐私计算算法开发诉求的同学，可以根据自身场景和业务的特点，设计出一些特化的隐私计算算法，来满足自身业务和场景对安全性、计算性能和计算精度的平衡。在这一层上，隐语本身也会提供一些通用的算法能力，比如MPC的LR/XGB/NN，联邦学习算法，SQL能力等。</span></p><p id="ucae8a6d7" class="ne-p"><span class="ne-text"></span></p><p id="u9f7a7984" class="ne-p"><span class="ne-text">逻辑设备抽象为算法开发者提供了极大的灵活性，他们可以像积木一样自由组合这些设备，在设备上自定义计算，从而构建自己的隐私计算算法。后文第六部分将通过一个具体的算法来展示隐语框架的通用编程能力。</span></p><h2 id="BOf6V"><span class="ne-text">“隐语”框架的使用</span></h2><h3 id="SFjrR"><span class="ne-text">使用隐语构建隐私计算算法</span></h3><p id="u5d9cb653" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="u06ca563e" class="ne-p" style="line-height: 1.5"><span class="ne-text">逻辑设备抽象为算法开发者提供了极大的灵活性，他们可以像积木一样自由组合这些设备，在设备上自定义计算，从而构建自己的隐私计算算法。接下来，我们通过一个具体的算法来展示隐语框架的通用编程能力。</span></p><p id="u741afc83" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><h4 id="CC4Ti"><span class="ne-text">联邦学习算法</span></h4><p id="u39da22a3" class="ne-p" style="line-height: 1.5"><span class="ne-text">联邦机器学习又名联邦学习，联合学习，联盟学习，是一种机器学习框架，能有效帮助多个机构在满足用户隐私保护、数据安全和政府法规的要求下，进行数据使用和机器学习建模。</span></p><p id="uf0c34314" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="uf89d1970" class="ne-p" style="text-align: left; line-height: 1.5"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470051929-5f3dee48-4f27-42e8-99f1-cb7e75ff5a8b.png" width="445" id="wCdgM" class="ne-image"></p><p id="ua390fdb3" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="ub5d67147" class="ne-p" style="line-height: 1.5"><span class="ne-text">联邦学习的算法流程如上图所示，大致分为以下四个步骤</span></p><p id="ub5d0672c" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><ol class="ne-ol"><li id="u922b166a" style="line-height: 1.5"><span class="ne-text">机构节点在本地进行多轮训练，得到模型参数</span></li><li id="u3964c9aa" style="line-height: 1.5"><span class="ne-text">机构节点使用加密协议，将模型参数上传至聚合节点</span></li><li id="u9e864bbb" style="line-height: 1.5"><span class="ne-text">聚合节点使用加密协议，对模型参数进行聚合，得到全局模型</span></li><li id="uc0bac6ca" style="line-height: 1.5"><span class="ne-text">机构节点从聚合节点获取最新的全局模型，进入下一轮训练</span></li></ol><p id="u1c671a36" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="ud1cf72e8" class="ne-p"><strong><span class="ne-text">节点本地训练</span></strong></p><p id="u86657cbc" class="ne-p" style="line-height: 1.5"><span class="ne-text">机构节点运行在机构本地，隐语提供了一个逻辑设备</span><code class="ne-code"><span class="ne-text">PYU</span></code><span class="ne-text">，执行本地的明文计算。下面的</span><code class="ne-code"><span class="ne-text">BaseTFModel</span></code><span class="ne-text">定义了本地模型训练逻辑，用户可以选择自己喜好的机器学习框架，如TensorFlow, PyTorch等。隐语提供了</span><code class="ne-code"><span class="ne-text">@proxy</span></code><span class="ne-text">装饰器，对一个普通的类进行了初始设置，以便后续在逻辑设备上对其实例化。</span><code class="ne-code"><span class="ne-text">@proxy(PYUObject)</span></code><span class="ne-text">表明该类需要在PYU设备上实例化。</span></p><p id="u58089295" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><pre data-language="python" id="MnclY" class="ne-codeblock language-python">@proxy(PYUObject)
class BaseTFModel:
    def train_step(self, weights, cur_steps, train_steps) -&gt; Tuple[np.ndarray, int]:
        self.model.set_weights(weights)
        num_sample = 0
        for _ in range(train_steps):
            x, y = next(self.train_set)
            num_sample += x.shape[0]
            self.model.fit(x, y)

        return self.model.get_weights(), num_sample</pre><p id="u816990e9" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="u3c96d702" class="ne-p"><strong><span class="ne-text">模型安全聚合</span></strong></p><p id="u7e211584" class="ne-p" style="line-height: 1.5"><span class="ne-text">模型聚合对各个机构节点的模型参数进行加权平均，如下面</span><code class="ne-code"><span class="ne-text">_average</span></code><span class="ne-text">所示。隐语逻辑设备的最大特点在于可编程性，用户可以将一段函数调度到多种设备执行，以达到使用不同隐私计算技术的目的。目前，</span><code class="ne-code"><span class="ne-text">DeviceAggregator</span></code><span class="ne-text">可以支持PYU明文聚合，也可以支持SPU MPC协议聚合，后续我们还将支持TEE, HEU等多种密文设备。</span></p><p id="ud59d8024" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><pre data-language="python" id="L7LsI" class="ne-codeblock language-python">@dataclass
class DeviceAggregator(Aggregator):
    device: Union[PYU, SPU]

    def average(self, data: List[DeviceObject], axis=0, weights=None):
        # 2. 机构节点使用加密协议，将模型参数上传至聚合节点
        data = [d.to(self.device) for d in data]
        if isinstance(weights, (list, tuple)):
            weights = [w.to(self.device) if isinstance(w, DeviceObject) else w for w in weights]

        def _average(data, axis, weights):
            return [jnp.average(element, axis=axis, weights=weights) for element in zip(*data)]

        # 3. 聚合节点使用加密协议，对模型参数进行聚合，得到全局模型
        return self.device(_average, static_argnames='axis')(data, axis=axis, weights=weights)</pre><p id="u1bc3d893" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="uf8404062" class="ne-p"><strong><span class="ne-text">训练流程整合</span></strong></p><p id="uf64a6976" class="ne-p" style="line-height: 1.5"><span class="ne-text">有了节点本地训练、模型安全聚合，我们就可以将其整合起来形成完整的训练流程。首先，我们在每个PYU设备（代表机构节点）创建BaseTFModel实例。同时，初始化聚合器，可以是PYU, SPU, TEE, Secure Aggregation。然后，按照上述描述的联邦学习算法流程进行迭代训练。</span></p><p id="uff120adf" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><pre data-language="python" id="l2jjU" class="ne-codeblock language-python">class FedTFModel:
    def __init__(self, device_list: List[PYU] = [], model: Callable[[], tf.keras.Model] = None, aggregator=None):
        # 在每个机构节点(PYU)创建一个BaseTFModel实例
        self._workers = {device: BaseTFModel(
            model, device=device) for device in device_list}
        # 聚合器，可以是PYU, SPUPPU, TEE, Secure Aggregation
        self._aggregator = aggregator

    def fit(self, x: Union[HDataFrame, FedNdarray], y: Union[HDataFrame, FedNdarray], batch_size=32, epochs=1, verbose='auto',
            callbacks=None, validation_data=None, shuffle=True,
            class_weight=None, sample_weight=None, validation_freq=1, aggregate_freq=1):
        self.handle_data(train_x, train_y, batch_size=batch_size,
                         shuffle=shuffle, epochs=epochs)

        # 初始化模型参数
        current_weights = {
            device: worker.get_weights() for device, worker in self._workers.items()}

        for epoch in range(epochs):
            for step in range(0, self.steps_per_epoch, aggregate_freq):
                weights, sample_nums = [], []
                for device, worker in self._workers.items():
                    # 1. 机构节点在本地进行多轮训练，得到模型参数
                    weight, sample_num = worker.train_step(current_weights[device], epoch*self.steps_per_epoch+step, aggregate_freq)
                    weights.append(weight)
                    sample_nums.append(sample_num)
                # 模型参数聚合，可以是：PYU, SPU, TEE, Secure Aggregation
                current_weight = self._aggregator.average(
                    weights, weights=sample_nums)
                # 4. 机构节点从聚合节点获取最新的全局模型，进入下一轮训练
                current_weights = {device: current_weight.to(device) for device, worker in self._workers.items()}</pre><p id="u450c39e9" class="ne-p" style="line-height: 1.5"><span class="ne-text" style="color: #595959"></span></p><p id="ua7a67a0e" class="ne-p" style="line-height: 1.5"><span class="ne-text">以上就是使用隐语提供的设备抽象进行联邦学习算法开发的关键步骤，完整的算法流程，可以参考隐语开发者文档中的更多实例：</span><span class="ne-text">基于联邦学习的图片分类任务</span><span class="ne-text">，可以下载并运行它看看效果。</span></p><p id="u105b13dd" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><h4 id="ALEHq"><span class="ne-text">更多算法</span></h4><p id="u53997f67" class="ne-p" style="line-height: 1.5"><span class="ne-text">通过以上联邦学习算法的例子，我们展示了隐语作为隐私计算框架的可编程性、可扩展性。更多详情请参考我们的</span><a href="https://secretflow.readthedocs.io/zh_CN/latest/tutorial/index.html" data-href="https://secretflow.readthedocs.io/zh_CN/latest/tutorial/index.html" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">教程和实现</span></a><span class="ne-text">，也期待您基于隐语探索更多有趣的用法！</span></p><p id="u767c4ab7" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ucf1458bf" style="line-height: 1.5"><span class="ne-text">在SPU进行PSI对齐，逻辑回归、神经网络训练</span></li><li id="u0285ce71" style="line-height: 1.5"><span class="ne-text">使用SPU HEU的组合构建HESS-LR, HESS-XGB算法</span></li><li id="u222f1192" style="line-height: 1.5"><span class="ne-text">横向联邦学习，在PYU进行本地训练，使用SPU、TEE、Secure Aggregation进行梯度、权重聚合</span></li><li id="ua03454dd" style="line-height: 1.5"><span class="ne-text">纵向拆分学习，将一个模型拆分至多个PYU，使用PYU聚合隐层，使用差分隐私保护前向隐层和反向梯度</span></li></ul><p id="u55511bb6" class="ne-p" style="line-height: 1.5"><span class="ne-text"></span></p><p id="u710d9d77" class="ne-p" style="text-align: justify; line-height: 1.5"><strong><span class="ne-text" style="color: rgb(0, 128, 255); font-size: 14px">隐语介绍：</span></strong></p><p id="ue8090855" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(34, 34, 34); font-size: 14px">隐语Secret-Flow是蚂蚁集团自主研发的一套通用隐私计算框架，以安全、开放为设计理念，支持包括MPC、TEE、FL、HE、DP在内的多种主流隐私计算技术。目前“隐语”已正式开源，诚挚邀请业界同行参与隐语共建，丰富隐私计算落地场景，齐力推动隐私计算技术发展，最终实现整个隐私计算行业的进步。</span></p><p id="ude07b1dd" class="ne-p" style="text-align: center"><br></p><h3 id="W03Th"><span class="ne-text">加入社区</span></h3><p id="u760e4383" class="ne-p" style="text-align: left; line-height: 2"><span class="ne-text">🔗</span><a href="https://www.secretflow.org.cn" data-href="https://www.secretflow.org.cn" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">官网</span></a><span class="ne-text">    🔗</span><a href="https://github.com/secretflow" data-href="https://github.com/secretflow" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">代码</span></a><span class="ne-text">    🔗</span><a href="https://secretflow.readthedocs.io/zh_CN/latest/tutorial/index.html#" data-href="https://secretflow.readthedocs.io/zh_CN/latest/tutorial/index.html#" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">文档</span></a><span class="ne-text">    🔗</span><a href="https://survey.alipay.com/apps/zhiliao/FdC-vTsPM" data-href="https://survey.alipay.com/apps/zhiliao/FdC-vTsPM" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">体验</span></a><span class="ne-text">    🔗</span><a href="https://secretflow.zhubai.love/" data-href="https://secretflow.zhubai.love/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">订阅</span></a><span class="ne-text">    🔗</span><a href="https://space.bilibili.com/2073575923" data-href="https://space.bilibili.com/2073575923" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">视频</span></a></p><p id="u2f2087d2" class="ne-p" style="text-align: left; line-height: 2"><span class="ne-text">官方邮箱：</span><strong><span class="ne-text" style="color: rgb(0, 0, 0)">secretflow-contact@service.alipay.com</span></strong></p><p id="u8b18573c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/27064845/1660553616030-d22fc5d5-36d2-4a7b-99fc-2a9fd87e9ec6.png" width="1491" id="u2526e9bf" class="ne-image"></p></div>