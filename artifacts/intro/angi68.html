---
title: 隐语密态计算设备SPU
toc: content
dateModified: 2022-10-14T10:25:54.000Z
---
<!doctype html><div class="lake-content" typography="classic"><h2 id="Kfc2y"><span class="ne-text">创新点之密态计算设备</span><span class="ne-text" style="color: rgb(0, 0, 0)">SPU</span></h2><p id="u24b80844" class="ne-p"><span class="ne-text">SPU是</span><em><span class="ne-text">Secretflow Processing Unit</span></em><span class="ne-text"> 的简称，她作为隐语平台的密态计算单元，为隐语提供安全的计算服务：</span></p><p id="u513c1fc1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470423184-3b67ba9e-d1e5-42b1-bcec-d94ae2ee724d.png" width="796" id="u97a8ca1e" class="ne-image"></p><h3 id="umBtk"><span class="ne-text">1.SPU概念理解</span></h3><p id="u3c3d8be6" class="ne-p"><span class="ne-text">密态计算单元这个概念听起来比较晦涩，我们用一个实际的例子介绍一下SPU的作用。</span></p><p id="uffa254ab" class="ne-p"><span class="ne-text">假设要用 </span><a href="https://jax.readthedocs.io/en/latest/" data-href="https://jax.readthedocs.io/en/latest/" target="_blank" class="ne-link"><span class="ne-text">JAX</span></a><span class="ne-text"> 写逻辑回归（SPU不依赖JAX，选择JAX因为简单），代码如下：</span></p><pre data-language="python" id="HE02c" class="ne-codeblock language-python">import jax
import jax.numpy as jnp

def sigmoid(x):
    return 1 / (1 + jnp.exp(-x))

def loss(x, y, w):
    pred = sigmoid(jnp.dot(x, w))
    label_prob = pred * y + (1 - pred) * (1 - y)
    return -jnp.sum(jnp.log(label_prob))

def logit_regression(x, y, epochs=3, step_size=0.1):
    w = jnp.zeros(x.shape[1])
    for _ in range(epochs):
        grad = jax.grad(loss, 2)(x, y, w)
        w -= grad * step_size
    return w

x, y = load_full_dataset()
w = fit(x, y)</pre><p id="u4e5d072a" class="ne-p"><em><span class="ne-text" style="font-size: 13px">【注】JAX是Google推出的AI框架，可以对numpy 自动求导，并且在CPU/GPU/TPU上执行</span></em></p><p id="u059fb2d3" class="ne-p"><em><span class="ne-text" style="font-size: 13px">【注】L15 使用了JAX的自动求导功能，对loss function进行了求导</span></em></p><p id="u905223dc" class="ne-p"><span class="ne-text"></span></p><p id="u71c3819c" class="ne-p"><span class="ne-text">对于上述程序，JAX提供了jit（全称Just In Time，是编译技术的一种）方法，</span><strong><span class="ne-text">在不用任何算法改动的前提下将上述程序编译到GPU上，从而加速执行</span></strong><span class="ne-text">。</span></p><pre data-language="python" id="qtsXo" class="ne-codeblock language-python">jax.jit(logit_regression)(x, y)  # jax.jit将logit_regression翻译到GPU执行</pre><p id="u455a097b" class="ne-p"><span class="ne-text">JAX 本质解决了两个问题</span></p><ol class="ne-ol"><li id="u6c549f0a"><span class="ne-text">降低开发成本，在用户无感的情况下，利用GPU/TPU进行加速</span></li><li id="u83fbf092"><span class="ne-text">降低学习成本，通过兼容numpy API 并提供自动求到来吸引开发者</span></li></ol><p id="u35e5660b" class="ne-p"><span class="ne-text"></span></p><p id="udcdf4738" class="ne-p"><span class="ne-text">沿着这个思路，对安全计算做个类比</span></p><ul class="ne-ul"><li id="u8f05858f"><strong><span class="ne-text">JAX可以利用并行设备进行计算加速</span></strong><span class="ne-text">，</span><strong><span class="ne-text">我们可否用安全设备进行安全加固？</span></strong></li><li id="u9ecb8d47"><strong><span class="ne-text">JAX可以复用numpy API，我们是否可以复用其他AI框架API？</span></strong></li></ul><p id="u98f90a34" class="ne-p"><span class="ne-text"></span></p><p id="u45925a7f" class="ne-p"><span class="ne-text">带着这两个问题，</span><strong><span class="ne-text" style="color: #E8323C">SPU的核心API就是这样一个函数，将AI模型翻译到安全设备上执行</span></strong></p><pre data-language="python" id="NktRQ" class="ne-codeblock language-python">spu.jit(logit_regression)(x, y)</pre><p id="u123fab52" class="ne-p"><span class="ne-text">为了实现这个函数，我们需要两个子模块</span></p><ul class="ne-ul"><li id="u63db43b3"><span class="ne-text">SPU (Jit) Compiler: 将原生的AI 程序翻译成 SPU字节码</span></li><li id="ub6aef272"><span class="ne-text">SPU VM：一个带安全语义的虚拟机，解释和执行SPU字节码</span></li></ul><p id="u610d2b66" class="ne-p"><span class="ne-text"></span></p><p id="ufe063b1b" class="ne-p"><span class="ne-text">实际实现稍微复杂一些</span></p><ul class="ne-ul"><li id="u4a097d7b"><span class="ne-text">将Tensorflow/PyTorch/JAX 翻译成SPU字节码本身是个复杂繁琐的工作</span></li><li id="udf5cacf1"><span class="ne-text">SPU字节码使用的是密文类型系统，譬如没有f32/f64等，类型系统需要重新设计</span></li><li id="u855871a8"><span class="ne-text">SPU后端是MPC，本质上是个分布式系统，需要处理分布式系统的通信和协作</span></li><li id="u60d5d487"><span class="ne-text">上述程序中，变量</span><code class="ne-code"><span class="ne-text">x, y</span></code><span class="ne-text">可能由不同的参与方提供，所以IO模块有些特别</span></li></ul><p id="ud28f7eb5" class="ne-p"><span class="ne-text">细节会在后续部分进行简单介绍，在此不再复述。</span></p><h3 id="TQ3wn"><span class="ne-text">2.SPU的功能作用</span></h3><p id="uc7249341" class="ne-p"><span class="ne-text">介绍完SPU是什么，我们再来理一下为什么。</span></p><p id="u7481da11" class="ne-p"><span class="ne-text">市面上的隐私计算框架有很多，比如 TFE，CrypTen，MP-SPDZ 等，</span><strong><span class="ne-text">为什么我们要重新造一套轮子呢？</span></strong></p><h4 id="txs7p"><span class="ne-text">领域之间的距离</span></h4><p id="u97bdbe98" class="ne-p"><span class="ne-text">安全机器学习是一个交叉领域，其实AI和安全之间有相当的距离。比如</span></p><ul class="ne-ul"><li id="u614af1a7"><span class="ne-text">安全开发者更关注基础算子，比如加减乘除的安全性</span></li><li id="u5d0d1d0d"><span class="ne-text">AI开发者更关注高阶算子，比如conv，tensordot</span></li></ul><p id="uc24603bd" class="ne-p"><span class="ne-text">高阶算子和基础算子之间，有很大一段距离，譬如：</span></p><ul class="ne-ul"><li id="u9ee799f0"><span class="ne-text">机器学习编译器处理的 lowering/tiling/fusing等</span></li><li id="u93fa6ad7"><span class="ne-text">运行时处理的的调度，并发等</span><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470423165-b498d0d9-c927-46ec-bbfd-a99f0b3dabdf.png" width="1080" id="ufaf2c85a" class="ne-image"></li></ul><p id="u297ab8c9" class="ne-p"><span class="ne-text">无论是基于AI框架（TFE/CrypTen），还是从安全计算出发的框架（SPDZ），都有自己的问题。前者往往难部署，难做安全领域特定的优化。后者往往会需要写一些Toy AI框架，学习成本高。</span></p><p id="u1436300b" class="ne-p"><span class="ne-text"></span></p><p id="u9e92a08b" class="ne-p"><strong><span class="ne-text">SPU试图缝合这两个领域之间的间隙</span></strong><span class="ne-text">，使得：</span></p><ul class="ne-ul"><li id="u5d7a368c"><span class="ne-text">向上，SPU原生对接AI框架（TF/JAX/PyTorch)，</span><strong><span class="ne-text">降低AI开发者的学习和开发成本</span></strong><span class="ne-text">。</span></li><li id="u88f60022"><span class="ne-text">向下，SPU提供纯粹安全语义接口，只需要实现很少的安全协议（比如加乘与或）就能跑起来复杂的模型，</span><strong><span class="ne-text">让目光更聚焦安全本身。</span></strong></li></ul><p id="ub9d09e4c" class="ne-p"><br></p><h4 id="fkPDm"><span class="ne-text">算力和需求的距离</span></h4><p id="ufbcb9765" class="ne-p"><span class="ne-text">近些年，密态计算（MPC/HE）在算力上都巨大的进步，但是</span><strong><span class="ne-text">密态算力和AI的算法需求还是难以匹配</span></strong><span class="ne-text">。在算力无法匹配算法的时候，</span><strong><span class="ne-text">一个直观的想法就是“明密文混合”</span></strong><span class="ne-text">，</span><strong><span class="ne-text" style="color: #E8323C">用来做安全和性能的tradeoff</span></strong><span class="ne-text">。比如联邦学习，将算法的某一个子步骤使用安全计算实现，牺牲局部安全性以换取更高的性能。</span></p><p id="u6f0dfc6b" class="ne-p"><span class="ne-text">隐语提供了非常自由的明密文混合编程范式，我们不限制明文的引擎，也不限制密文引擎，开发者可以用他自己熟悉的框架开发，然后标记其中的某一部分用明文引擎跑，另一部分用SPU跑。比如</span></p><p id="u9deca64e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470423224-ad690c30-8680-41cc-b08c-c0debcac6dd9.png" width="681.818167040171" id="u3edaf200" class="ne-image"></p><p id="u5fcb91e3" class="ne-p"><em><span class="ne-text" style="font-size: 13px">【注】图中MPC Device就是SPU实现的</span></em></p><p id="u6c597780" class="ne-p"><em><span class="ne-text" style="font-size: 13px"></span></em></p><p id="ub675f82b" class="ne-p"><span class="ne-text">作为对比，从安全和性能这种的角度，无论TFE/CrypTen/SPDZ等都很难进行这种tradeoff。</span></p><p id="ue0bdb228" class="ne-p"><span class="ne-text"></span></p><h4 id="XkZIH"><span class="ne-text">理论和落地的距离</span></h4><p id="u154c9d25" class="ne-p"><span class="ne-text">多方安全计算天然是一个分布式的系统，部署模式非常多样，比如：</span></p><ul class="ne-ul"><li id="u1da95857"><span class="ne-text">论文中经常假设计算方和数据提供方分离（outsourcing）</span></li><li id="uab0262fb"><span class="ne-text">真正进行业务落地时，数据提供方往往同时也是计算方（colocated）</span></li><li id="ua1c80d0b"><span class="ne-text">在一个复杂的隐私计算网络里，计算方和数据方可以是任意组合的（hybrid）</span></li></ul><p id="u6d851ca0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470422583-8c77a037-5ad9-436e-b969-fb1ff5373b55.png" width="587.272714543934" id="GILjz" class="ne-image"></p><p id="u99af3f47" class="ne-p"><em><span class="ne-text" style="font-size: 13px">如图，我们用三角形表示计算节点，圆形表示数据提供节点（不同颜色表示互不信任）</span></em></p><p id="u09c27d3c" class="ne-p"><br></p><p id="u8121f2aa" class="ne-p"><span class="ne-text">SPU被设计成部署模式透明的，不用修改任何一行代码，你的模型都可以在上述任何一种部署场景上被安全且正确的执行。并且（相对于基于AI平台的隐私计算框架）</span><strong><span class="ne-text">SPU运行时非常的轻量级，不需要Python runtime，可以方便的进行部署和集成</span></strong><span class="ne-text">。</span></p><p id="ued7f490e" class="ne-p"><br></p><p id="uddf95f9f" class="ne-p"><span class="ne-text">所以，Why SPU？</span></p><p id="u0ae29951" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">作为AI开发者，你不需要任何安全背景，就可以将你现有的模型安全的应用到多方数据上。</span></strong></p><p id="ua0dfbe80" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">作为安全开发者，你不需要任何AI背景，仅仅实现安全计算的基本算子，就可以支持多种前端框架。</span></strong></p><p id="u16fa7f29" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">并且，你可以方便的部署和运维，在安全和性能之间折中，找到最佳的落地方案。</span></strong></p><h3 id="BcBEP"><span class="ne-text">3.SPU的架构</span></h3><p id="u94cb0eb0" class="ne-p"><span class="ne-text">介绍完是什么和为什么之后，我们简单介绍一下SPU的架构。</span></p><p id="u10443e6e" class="ne-p"><span class="ne-text">SPU上层对接了</span><a href="https://www.tensorflow.org/xla" data-href="https://www.tensorflow.org/xla" target="_blank" class="ne-link"><span class="ne-text">XLA-HLO</span></a><span class="ne-text">，然后利用MLIR将HLO翻译成SPU IR，最后交给SPU VM进行解释执行，如图：</span></p><p id="u87d990ea" class="ne-p"><span class="ne-text"></span></p><h4 id="Od00J"><span class="ne-text">Workflow</span></h4><p id="u27c0d417" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470423867-a5e4fe16-9ac8-4c63-b872-61139a02881e.png" width="489" id="ue98bed8b" class="ne-image"></p><p id="u1c72ba74" class="ne-p"><span class="ne-text">基本工作流程是：</span></p><ol class="ne-ol"><li id="u2959878c"><span class="ne-text">开发人员用自己熟悉的框架建模，然后用AI compiler将模型编译成 XLA IR。</span></li><li id="uf8c2a034"><span class="ne-text">SPU compiler将XLA IR编译成SPU IR（SPU字节码）</span></li><li id="u82332b86"><span class="ne-text">参与方（Alice/Bob/Charlie) 将数据 infeed 给SPU VM</span></li><li id="u6376acd0"><span class="ne-text">SPU VM执行字节码，接收输入，安全计算，并且产生输出</span></li><li id="u03344beb"><span class="ne-text">参与方协商将结果解密输出到某处</span></li></ol><h4 id="NhaVk"><span class="ne-text">Why XLA？</span></h4><p id="u07f6220b" class="ne-p"><span class="ne-text">这里对于XLA不熟悉的同学进行一个简单介绍，XLA 是一种针对特定领域的线性代数编译器，是tensorflow内部实现的一个子模块，使用编译器相关技术用来加速模型的执行。XLA加速的基本原理看</span><a href="https://www.tensorflow.org/xla/architecture#xla_%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" data-href="https://www.tensorflow.org/xla/architecture#xla_%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" target="_blank" class="ne-link"><span class="ne-text">这里</span></a><span class="ne-text">。</span></p><p id="ubfef19ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470424798-4529f105-c49e-421b-bf90-68c203bb4564.png" width="293.1647644042969" id="ub48dd35d" class="ne-image"></p><p id="u9bec945d" class="ne-p"><span class="ne-text">我们可以将SPU理解成一个带安全语义的Backend，对接</span><a href="https://www.tensorflow.org/xla" data-href="https://www.tensorflow.org/xla" target="_blank" class="ne-link"><span class="ne-text">XLA</span></a><span class="ne-text">的理由</span><strong><span class="ne-text">是Tensorflow/Jax/PyTorch计算图最终都可以翻译到XLA IR，只要SPU可以解释和执行XLA IR，理论上就可以原生支持多种AI前端</span></strong><span class="ne-text">。所以理论上并不是选择了XLA编译器，而是选择了XLA IR 作为AI和MPC的桥梁。</span></p><h4 id="JtnVs"><span class="ne-text">Arch</span></h4><p id="u5762a984" class="ne-p"><span class="ne-text">下面简单介绍一下SPU的编译和执行过程</span></p><p id="u77d4a2b9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/29690418/1658470425789-5dd6e323-7d52-4e5e-ae61-e5198fa51bd5.png" width="400.4488525390625" id="u2d54a10d" class="ne-image"></p><ul class="ne-ul"><li id="u5d68cdc4"><span class="ne-text">前端，我们依赖AI前端将python代码翻译成XLA IR</span></li><li id="u71cbbbd3"><span class="ne-text">编译器，我们使用MLIR技术栈对HLO进行优化并翻译成PPHLO（SPU字节码）</span></li><li id="ud0bc49ea"><span class="ne-text">运行时，我们逐渐将Tensor ops拆解，经过SPU HAL(硬件抽象层，处理fxp/int)，最终dispatch到协议层</span></li><li id="ufc7f166d"><span class="ne-text">协议层只需要实现Ring or Field上的基础运算即可</span></li></ul><p id="u6d9887b1" class="ne-p"><span class="ne-text"></span></p><p id="u69d7bfa7" class="ne-p"><span class="ne-text">最终，通过编译时和运行时的层层翻译，</span><strong><span class="ne-text">SPU将AI前端和MPC后端解耦，使得在SPU中扩展的任何安全协议都可以无感的支持多种前端</span></strong><span class="ne-text">。</span></p><h4 id="QJV44"><span class="ne-text">Optimization</span></h4><p id="u46e5698a" class="ne-p"><span class="ne-text">SPU完全自主研发，所以我们可以针对安全计算的特点进行优化，比如</span></p><ul class="ne-ul"><li id="u91b4b504"><span class="ne-text">针对MPC延时敏感的计算类型进行并发调度</span></li><li id="u97305424"><span class="ne-text">针对特定协议设计特殊的VM指令集</span></li><li id="ue5c493f7"><span class="ne-text">基于C++语言，开发者可以得到Low-level access，更有效的榨取性能</span></li></ul><p id="u551d35f3" class="ne-p"><span class="ne-text">具体细节在此不再复述。</span></p><p id="ufcca24b2" class="ne-p"><span class="ne-text"></span></p><p id="ua6e1ffff" class="ne-p"><span class="ne-text">SPU依然在一个高速迭代过程中，隐语期待更多的AI专家、编译专家、安全专家参与共建。</span></p><p id="uecd10fa0" class="ne-p"><span class="ne-text"></span></p><p id="u8956e3c8" class="ne-p" style="text-align: justify"><strong><span class="ne-text" style="color: rgb(0, 128, 255); font-size: 14px">隐语介绍：</span></strong></p><p id="ue8090855" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(34, 34, 34); font-size: 14px">隐语Secret-Flow是蚂蚁集团自主研发的一套通用隐私计算框架，以安全、开放为设计理念，支持包括MPC、TEE、FL、HE、DP在内的多种主流隐私计算技术。目前“隐语”已正式开源，诚挚邀请业界同行参与隐语共建，丰富隐私计算落地场景，齐力推动隐私计算技术发展，最终实现整个隐私计算行业的进步。</span></p><p id="u0e1464c2" class="ne-p"><span class="ne-text"></span></p><h2 id="ClTTO"><span class="ne-text">加入社区</span></h2><p id="u760e4383" class="ne-p" style="text-align: left; line-height: 2"><span class="ne-text">🔗</span><a href="https://www.secretflow.org.cn" data-href="https://www.secretflow.org.cn" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">官网</span></a><span class="ne-text">    🔗</span><a href="https://github.com/secretflow" data-href="https://github.com/secretflow" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">代码</span></a><span class="ne-text">    🔗</span><a href="https://secretflow.readthedocs.io" data-href="https://secretflow.readthedocs.io" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">文档</span></a><span class="ne-text">    🔗</span><a href="https://survey.alipay.com/apps/zhiliao/FdC-vTsPM" data-href="https://survey.alipay.com/apps/zhiliao/FdC-vTsPM" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">体验</span></a><span class="ne-text">    🔗</span><a href="https://secretflow.zhubai.love/" data-href="https://secretflow.zhubai.love/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">订阅</span></a><span class="ne-text">    🔗</span><a href="https://space.bilibili.com/2073575923" data-href="https://space.bilibili.com/2073575923" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: underline">视频</span></a></p><p id="u2f2087d2" class="ne-p" style="text-align: left; line-height: 2"><span class="ne-text">官方邮箱：</span><strong><span class="ne-text" style="color: rgb(0, 0, 0)">secretflow-contact@service.alipay.com</span></strong></p><p id="u8b18573c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/27064845/1660553616030-d22fc5d5-36d2-4a7b-99fc-2a9fd87e9ec6.png" width="1491" id="u2526e9bf" class="ne-image"></p></div>