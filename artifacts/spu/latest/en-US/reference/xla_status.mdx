:target{#xla-implementation-status}

# XLA Implementation Status

List of XLA(mhlo-mlir) Ops that SPU supports:

```none
The list of mhlo ops is obtained from this file:
    https://github.com/openxla/xla/blob/main/xla/mlir_hlo/mhlo/IR/hlo_ops.td

General limitation with SPU:
    * Dynamic shape is not supported
    * Complex number is not supported
    * SPU only supports fixed-point numbers, so no-finite is not supported
```

:target{#xla-nullary-ops}

## XLA nullary ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `constant`
      </td>

      <td>
        fully
      </td>

      <td>
        Always yields a public value
      </td>
    </tr>

    <tr>
      <td>
        `iota`
      </td>

      <td>
        fully
      </td>

      <td>
        Always yields a public value
      </td>
    </tr>

    <tr>
      <td>
        `dynamic_iota`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `create_token`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 4, fully supported = 2

:target{#xla-unary-element-wise-ops}

## XLA unary element-wise ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `abs`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `cbrt`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `ceil`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `convert`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `count_leading_zeros`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `cosine`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `exponential`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `exponential_minus_one`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `floor`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `imag`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `is_finite`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `log`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `log_plus_one`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `logistic`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `not`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `negate`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `popcnt`
      </td>

      <td>
        not
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `real`
      </td>

      <td>
        not
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `round_nearest_afz`
      </td>

      <td>
        not
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `rsqrt`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `sign`
      </td>

      <td>
        partial
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `sine`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `sqrt`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `tanh`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 24, fully supported = 16, partial = 1

:target{#xla-binary-element-wise-ops}

## XLA binary element-wise ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `add`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `atan2`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `complex`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `compare`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `divide`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `maximum`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `minimum`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `multiply`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `power`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `remainder`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `shift_left`
      </td>

      <td>
        partial
      </td>

      <td>
        rhs must be a public
      </td>
    </tr>

    <tr>
      <td>
        `shift_right_arithmetic`
      </td>

      <td>
        partial
      </td>

      <td>
        rhs must be a public
      </td>
    </tr>

    <tr>
      <td>
        `shift_right_logical`
      </td>

      <td>
        partial
      </td>

      <td>
        rhs must be a public
      </td>
    </tr>

    <tr>
      <td>
        `subtract`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 14, fully supported = 9, partial = 3

:target{#xla-binary-logical-element-wise-ops}

## XLA binary logical element-wise ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `and`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `or`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `xor`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 3, fully supported = 3

:target{#xla-communication-ops}

## XLA communication ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `infeed`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `outfeed`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `send`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `recv`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 4, fully supported = 0

:target{#xla-parallelism-related-ops}

## XLA parallelism related ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `replica_id`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 1, fully supported = 0

:target{#xla-control-flow-ops}

## XLA control flow ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `after_all`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `if`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `case`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `while`
      </td>

      <td>
        partial
      </td>

      <td>
        condition region must return a public scalar
      </td>
    </tr>

    <tr>
      <td>
        `all_gather`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `all_reduce`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `reduce_scatter`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `all_to_all`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `reduce`
      </td>

      <td>
        fully
      </td>

      <td>
        inherits limitations from reduce function
      </td>
    </tr>
  </tbody>
</table>

Count: Total = 9, fully supported = 2, partial = 1

:target{#xla-tuple-ops}

## XLA tuple ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `get_tuple_element`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `tuple`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 2, fully supported = 2

:target{#xla-other-ops}

## XLA other ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `slice`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic-slice`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic-update-slice`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `batch_norm_grad`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on XLA’s batchnorm\_expander pass
      </td>
    </tr>

    <tr>
      <td>
        `batch_norm_inference`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on XLA’s batchnorm\_expander pass
      </td>
    </tr>

    <tr>
      <td>
        `batch_norm_training`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on XLA’s batchnorm\_expander pass
      </td>
    </tr>

    <tr>
      <td>
        `bitcast_convert`
      </td>

      <td>
        partial
      </td>

      <td>
        Only supports convert to type of same size
      </td>
    </tr>

    <tr>
      <td>
        `broadcast`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `broadcast_in_dim`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic_broadcast_in_dim`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `cholesky`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on CholeskyExpander pass
      </td>
    </tr>

    <tr>
      <td>
        `clamp`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `concatenate`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `collective_permute`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `convolution`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `copy`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `cross-replica-sum`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `custom_call`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dot`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dot_general`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `einsum`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `unary_einsum`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `fft`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `gather`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `get_dimension_size`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `map`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on XLA’s MapInliner pass
      </td>
    </tr>

    <tr>
      <td>
        `reshape`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic_reshape`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `scatter`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `select`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `select_and_scatter`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `set_dimension_size`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `sort`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `reverse`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `pad`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `trace`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `transpose`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `triangular_solve`
      </td>

      <td>
        fully
      </td>

      <td>
        Rely on XLA’s TriangularSolverExpander pass
      </td>
    </tr>

    <tr>
      <td>
        `reduce_window`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `return`
      </td>

      <td>
        fully
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `torch_index_select`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `optimization_barrier`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 42, fully supported = 28, partial = 1

:target{#xla-rng-ops}

## XLA RNG ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `rng_uniform`
      </td>

      <td>
        partial
      </td>

      <td>
        Bound \[a, b) must all be public scalar, result is also a public tensor
      </td>
    </tr>

    <tr>
      <td>
        `rng_normal`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `rng_bit_generator`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 3, fully supported = 0, partial = 1

:target{#xla-quantize-op}

## XLA quantize op

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `dequantize`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 1, fully supported = 0, partial = 0

:target{#xla-miscellaneous-ops}

## XLA miscellaneous ops

<table>
  <thead>
    <tr>
      <td>
        Op Name
      </td>

      <td>
        supported(fully/partial/no)
      </td>

      <td>
        notes
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        `fusion`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `bitcast`
      </td>

      <td>
        no
      </td>

      <td>
        Internal op to XLA/GPU
      </td>
    </tr>

    <tr>
      <td>
        `reduce_precision`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `real_dynamic_slice`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic_pad`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic_gather`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `dynamic_conv`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `print`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `compute_reshape_shape`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>

    <tr>
      <td>
        `cstr_reshapable`
      </td>

      <td>
        no
      </td>

      <td>

      </td>
    </tr>
  </tbody>
</table>

Count: Total = 10, fully supported = 0, partial = 0
