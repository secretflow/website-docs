---
git_download_url: https://github.com/secretflow/psi/raw/557d03298c7d63bb5142258333a3114765f34c34/docs/reference/psi_v2_config.md
git_last_modified_commit: 1a914680c1fceeb259915b2f690bfe2a4670f06e
git_last_modified_time: '2023-12-21T21:24:38+08:00'
git_origin_url: https://github.com/secretflow/psi/blob/557d03298c7d63bb5142258333a3114765f34c34/docs/reference/psi_v2_config.md
git_owner: secretflow
git_repo: psi
git_revision_commit: 557d03298c7d63bb5142258333a3114765f34c34
git_revision_time: '2024-01-03T13:22:19+08:00'
---

:target{#psi-v2-configuration}

# PSI v2 Configuration

:target{#table-of-contents}

## Table of Contents

- Messages
  - [DebugOptions](#debugoptions)
  - [EcdhConfig](#ecdhconfig)
  - [InputConfig](#inputconfig)
  - [InternalRecoveryRecord](#internalrecoveryrecord)
  - [KkrtConfig](#kkrtconfig)
  - [OutputConfig](#outputconfig)
  - [ProtocolConfig](#protocolconfig)
  - [PsiConfig](#psiconfig)
  - [PsiReport](#psireport)
  - [RecoveryCheckpoint](#recoverycheckpoint)
  - [RecoveryConfig](#recoveryconfig)
  - [Rr22Config](#rr22config)
- Enums
  - [IoType](#iotype)
  - [Protocol](#protocol)
  - [PsiConfig.AdvancedJoinType](#psiconfig-advancedjointype)
  - [RecoveryCheckpoint.Stage](#recoverycheckpoint-stage)
  - [Role](#role)
- Messages
  - [ContextDescProto](#contextdescproto)
  - [PartyProto](#partyproto)
  - [RetryOptionsProto](#retryoptionsproto)
  - [SSLOptionsProto](#ssloptionsproto)
- [Scalar Value Types](#scalar-value-types)

:target{#messages}

## Messages

:target{#debugoptions}

### DebugOptions

Logging level for default logger.
Default to info.
Supports:

- trace: SPDLOG\_LEVEL\_TRACE
- debug: SPDLOG\_LEVEL\_DEBUG
- info: SPDLOG\_LEVEL\_INFO
- warn: SPDLOG\_LEVEL\_WARN
- err: SPDLOG\_LEVEL\_ERROR
- critical: SPDLOG\_LEVEL\_CRITICAL
- off: SPDLOG\_LEVEL\_OFF

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        logging\_level
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        trace\_path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        The path of trace. Deafult to /tmp/psi.trace
      </td>
    </tr>
  </tbody>
</table>

:target{#ecdhconfig}

### EcdhConfig

Configs for ECDH protocol.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        curve
      </td>

      <td>
        [<span> psi.psi.CurveType</span>](#psipsicurvetype)
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#inputconfig}

### InputConfig

Input configuration.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        type
      </td>

      <td>
        [ IoType](#iotype)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Required for FILE.
      </td>
    </tr>
  </tbody>
</table>

:target{#internalrecoveryrecord}

### InternalRecoveryRecord

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        stage
      </td>

      <td>
        [ RecoveryCheckpoint.Stage](#recoverycheckpoint-stage)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ecdh\_dual\_masked\_item\_peer\_count
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        parsed\_bucket\_count
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#kkrtconfig}

### KkrtConfig

Configs for KKRT protocol

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        bucket\_size
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        Since the total input may not fit in memory, the input may be splitted into buckets. bucket\_size indicate the number of items in each bucket. If the memory of host is limited, you should set a smaller bucket size. Otherwise, you should use a larger one. If not set, use default value: 1 \<\< 20.
      </td>
    </tr>
  </tbody>
</table>

:target{#outputconfig}

### OutputConfig

Output configuration.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        type
      </td>

      <td>
        [ IoType](#iotype)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Required for FILE.
      </td>
    </tr>
  </tbody>
</table>

:target{#protocolconfig}

### ProtocolConfig

Any items related to PSI protocols.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        protocol
      </td>

      <td>
        [ Protocol](#protocol)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        role
      </td>

      <td>
        [ Role](#role)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        broadcast\_result
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        Reveal result to sender.
      </td>
    </tr>

    <tr>
      <td>
        ecdh\_config
      </td>

      <td>
        [ EcdhConfig](#ecdhconfig)
      </td>

      <td>
        For ECDH protocol.
      </td>
    </tr>

    <tr>
      <td>
        kkrt\_config
      </td>

      <td>
        [ KkrtConfig](#kkrtconfig)
      </td>

      <td>
        For KKRT protocol.
      </td>
    </tr>

    <tr>
      <td>
        rr22\_config
      </td>

      <td>
        [ Rr22Config](#rr22config)
      </td>

      <td>
        For RR22 protocol.
      </td>
    </tr>
  </tbody>
</table>

:target{#psiconfig}

### PsiConfig

The top level of Configs.
run(PsiConfig)->PsiReport

Advanced Joins
Type: Inner Join
e.g. If input of receiver is

```default
| key1 | value1|
|------|-------|
| x    | 1     |
| x    | 2     |
| x    | 3     |
| y    | 4     |
```

and input of sender is

```default
| key2 | value2|
|------|-------|
| x    | a     |
| x    | b     |
| z    | c     |
```

After inner join.
The output of receiver is:

```default
| key1 | value1|
|------|-------|
| x    | 1     |
| x    | 2     |
| x    | 3     |
| x    | 1     |
| x    | 2     |
| x    | 3     |
```

The output of sender is

```default
| key2 | value2|
|------|-------|
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
```

Type: Left Join
After left join.
The output of left side is:

```default
| key1 | value1|
|------|-------|
| x    | 1     |
| x    | 2     |
| x    | 3     |
| x    | 1     |
| x    | 2     |
| x    | 3     |
| y    | 4     |
```

The output of right side is

```default
| key2 | value2|
|------|-------|
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| n/a  | n/a   |
```

Type: Right Join
After right join.
The output of left side is:

```default
| key1 | value1|
|------|-------|
| x    | 1     |
| x    | 2     |
| x    | 3     |
| x    | 1     |
| x    | 2     |
| x    | 3     |
| n/a  | n/a   |
```

The output of right side is

```default
| key2 | value2|
|------|-------|
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| z    | c     |
```

Type: Full Join
After full join.
The output of left side is:

```default
| key1 | value1|
|------|-------|
| x    | 1     |
| x    | 2     |
| x    | 3     |
| x    | 1     |
| x    | 2     |
| x    | 3     |
| y    | 4     |
| n/a  | n/a   |
```

The output of right side is

```default
| key2 | value2|
|------|-------|
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| x    | a     |
| x    | b     |
| n/a  | n/a   |
| z    | c     |
```

Type: Difference
After difference.
The output of left side is:

```default
| key1 | value1|
|------|-------|
| y    | 4     |
| n/a  | n/a   |
```

The output of right side is

```default
| key2 | value2|
|------|-------|
| n/a  | n/a   |
| z    | c     |
```

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        protocol\_config
      </td>

      <td>
        [ ProtocolConfig](#protocolconfig)
      </td>

      <td>
        Configs for protocols.
      </td>
    </tr>

    <tr>
      <td>
        input\_config
      </td>

      <td>
        [ InputConfig](#inputconfig)
      </td>

      <td>
        Configs for input.
      </td>
    </tr>

    <tr>
      <td>
        output\_config
      </td>

      <td>
        [ OutputConfig](#outputconfig)
      </td>

      <td>
        Configs for output.
      </td>
    </tr>

    <tr>
      <td>
        link\_config
      </td>

      <td>
        [<span> yacl.link.ContextDescProto</span>](#yacllinkcontextdescproto)
      </td>

      <td>
        Configs for network.
      </td>
    </tr>

    <tr>
      <td>
        self\_link\_party
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        keys
      </td>

      <td>
        [<span>repeated string</span>](#string)
      </td>

      <td>
        keys for intersection.
      </td>
    </tr>

    <tr>
      <td>
        debug\_options
      </td>

      <td>
        [ DebugOptions](#debugoptions)
      </td>

      <td>
        Logging level.
      </td>
    </tr>

    <tr>
      <td>
        skip\_duplicates\_check
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        If true, the check of duplicated items will be skiped.
      </td>
    </tr>

    <tr>
      <td>
        disable\_alignment
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        It true, output is not promised to be aligned.
      </td>
    </tr>

    <tr>
      <td>
        recovery\_config
      </td>

      <td>
        [ RecoveryConfig](#recoveryconfig)
      </td>

      <td>
        Configs for recovery.
      </td>
    </tr>

    <tr>
      <td>
        advanced\_join\_type
      </td>

      <td>
        [ PsiConfig.AdvancedJoinType](#psiconfig-advancedjointype)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        left\_side
      </td>

      <td>
        [ Role](#role)
      </td>

      <td>
        Required if advanced\_join\_type is ADVANCED\_JOIN\_TYPE\_LEFT\_JOIN or ADVANCED\_JOIN\_TYPE\_RIGHT\_JOIN.
      </td>
    </tr>

    <tr>
      <td>
        check\_hash\_digest
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        Check if hash digest of keys from parties are equal to determine whether to early-stop.
      </td>
    </tr>
  </tbody>
</table>

:target{#psireport}

### PsiReport

Execution Report.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        original\_count
      </td>

      <td>
        [<span> int64</span>](#int64)
      </td>

      <td>
        The data count of input.
      </td>
    </tr>

    <tr>
      <td>
        intersection\_count
      </td>

      <td>
        [<span> int64</span>](#int64)
      </td>

      <td>
        The count of intersection. Get `-1` when self party can not get result.
      </td>
    </tr>
  </tbody>
</table>

:target{#recoverycheckpoint}

### RecoveryCheckpoint

Save some critical information for future recovery.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        stage
      </td>

      <td>
        [ RecoveryCheckpoint.Stage](#recoverycheckpoint-stage)
      </td>

      <td>
        Stage of PSI.
      </td>
    </tr>

    <tr>
      <td>
        config
      </td>

      <td>
        [ PsiConfig](#psiconfig)
      </td>

      <td>
        A copy of origin PSI config.
      </td>
    </tr>

    <tr>
      <td>
        input\_hash\_digest
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Hash digest of input keys.
      </td>
    </tr>

    <tr>
      <td>
        ecdh\_dual\_masked\_item\_self\_count
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        Saved dual masked item count from self originally. PROTOCOL\_ECDH only.
      </td>
    </tr>

    <tr>
      <td>
        ecdh\_dual\_masked\_item\_peer\_count
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        Saved dual masked item count from peer originally. PROTOCOL\_ECDH only.
      </td>
    </tr>

    <tr>
      <td>
        parsed\_bucket\_count
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        Saved parsed bucket count. PROTOCOL\_KKRT and PROTOCOL\_RR22 only.
      </td>
    </tr>
  </tbody>
</table>

:target{#recoveryconfig}

### RecoveryConfig

Configuration for recovery.
If a PSI task failed unexpectedly, e.g. network failures and restart, the
task can resume to the latest checkpoint to save time.
However, enabling recovery would due in extra disk IOs and disk space
occupation.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        enabled
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        folder
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Stores status and checkpoint files.
      </td>
    </tr>
  </tbody>
</table>

:target{#rr22config}

### Rr22Config

Configs for RR22 protocol.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        bucket\_size
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        Since the total input may not fit in memory, the input may be splitted into buckets. bucket\_size indicate the number of items in each bucket. If the memory of host is limited, you should set a smaller bucket size. Otherwise, you should use a larger one. If not set, use default value: 1 \<\< 20.
      </td>
    </tr>

    <tr>
      <td>
        low\_comm\_mode
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#enums}

## Enums

:target{#iotype}

### IoType

TODO(junfeng): support more io types including oss, sql, etc.

<table>
  <thead>
    <tr>
      <td>
        Name
      </td>

      <td>
        Number
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        IO\_TYPE\_UNSPECIFIED
      </td>

      <td>
        0
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        IO\_TYPE\_FILE\_CSV
      </td>

      <td>
        1
      </td>

      <td>
        Local csv file.
      </td>
    </tr>
  </tbody>
</table>

:target{#protocol}

### Protocol

PSI protocols.

<table>
  <thead>
    <tr>
      <td>
        Name
      </td>

      <td>
        Number
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        PROTOCOL\_UNSPECIFIED
      </td>

      <td>
        0
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        PROTOCOL\_ECDH
      </td>

      <td>
        1
      </td>

      <td>
        \[Mea86]C. Meadows, “A More Efficient Cryptographic Matchmaking Protocol for Use in the Absence of a Continuously Available Third Party,” 1986 IEEE Symposium on Security and Privacy, Oakland, CA, USA, 1986, pp. 134-134, doi: 10.1109/SP.1986.10022.
      </td>
    </tr>

    <tr>
      <td>
        PROTOCOL\_KKRT
      </td>

      <td>
        2
      </td>

      <td>
        Efficient Batched Oblivious PRF with Applications to Private Set Intersection [https://eprint.iacr.org/2016/799.pdf](https://eprint.iacr.org/2016/799.pdf)
      </td>
    </tr>

    <tr>
      <td>
        PROTOCOL\_RR22
      </td>

      <td>
        3
      </td>

      <td>
        Blazing Fast PSI [https://eprint.iacr.org/2022/320.pdf](https://eprint.iacr.org/2022/320.pdf)
      </td>
    </tr>
  </tbody>
</table>

:target{#psiconfig-advancedjointype}

### PsiConfig.AdvancedJoinType

Advanced Join allow duplicate keys.

- If selected, duplicates\_check is skipped.
- If selected, both parties are allowed to contain duplicate keys.
- If use left join, full join or difference, the size of difference set of
  left party is revealed to right party.
- If use right join, full join or difference, the size of difference set of
  right party is revealed to left party.

<table>
  <thead>
    <tr>
      <td>
        Name
      </td>

      <td>
        Number
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_UNSPECIFIED
      </td>

      <td>
        0
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_INNER\_JOIN
      </td>

      <td>
        1
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_LEFT\_JOIN
      </td>

      <td>
        2
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_RIGHT\_JOIN
      </td>

      <td>
        3
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_FULL\_JOIN
      </td>

      <td>
        4
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ADVANCED\_JOIN\_TYPE\_DIFFERENCE
      </td>

      <td>
        5
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#recoverycheckpoint-stage}

### RecoveryCheckpoint.Stage

<table>
  <thead>
    <tr>
      <td>
        Name
      </td>

      <td>
        Number
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        STAGE\_UNSPECIFIED
      </td>

      <td>
        0
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        STAGE\_INIT\_END
      </td>

      <td>
        1
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        STAGE\_PRE\_PROCESS\_END
      </td>

      <td>
        2
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        STAGE\_ONLINE\_START
      </td>

      <td>
        3
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        STAGE\_ONLINE\_END
      </td>

      <td>
        4
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        STAGE\_POST\_PROCESS\_END
      </td>

      <td>
        5
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#role}

### Role

Role of parties.

<table>
  <thead>
    <tr>
      <td>
        Name
      </td>

      <td>
        Number
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        ROLE\_UNSPECIFIED
      </td>

      <td>
        0
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        ROLE\_RECEIVER
      </td>

      <td>
        1
      </td>

      <td>
        receiver In 2P symmetric PSI, receiver would always receive the result.
      </td>
    </tr>

    <tr>
      <td>
        ROLE\_SENDER
      </td>

      <td>
        2
      </td>

      <td>
        sender In 2P symmetric PSI, sender is the other participant apart from receiver.
      </td>
    </tr>
  </tbody>
</table>

:target{#id1}

## Messages

:target{#contextdescproto}

### ContextDescProto

Configuration for link config.

‘recv time’ is the max time that a party will wait for a given event.
for example:

```default
begin recv                 end recv
|--------|-------recv-time----------|------------------| alice's timeline

                        begin send     end send
|-----busy-work-------------|-------------|------------| bob's timeline
```

in above case, when alice begins recv for a specific event, bob is still
busy doing its job, when alice’s wait time exceed wait\_timeout\_ms, it raise
exception, although bob now is starting to send data.

so for long time work(that one party may wait for the others for very long
time), this value should be changed accordingly.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        id
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        the UUID of this communication. optional
      </td>
    </tr>

    <tr>
      <td>
        parties
      </td>

      <td>
        [repeated PartyProto](#partyproto)
      </td>

      <td>
        party description, describes the world.
      </td>
    </tr>

    <tr>
      <td>
        connect\_retry\_times
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        connect to mesh retry time.
      </td>
    </tr>

    <tr>
      <td>
        connect\_retry\_interval\_ms
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        connect to mesh retry interval.
      </td>
    </tr>

    <tr>
      <td>
        recv\_timeout\_ms
      </td>

      <td>
        [<span> uint64</span>](#uint64)
      </td>

      <td>
        recv timeout in milliseconds.
      </td>
    </tr>

    <tr>
      <td>
        http\_max\_payload\_size
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        http max payload size, if a single http request size is greater than this limit, it will be unpacked into small chunks then reassembled. This field does affect performance. Please choose wisely.
      </td>
    </tr>

    <tr>
      <td>
        http\_timeout\_ms
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        a single http request timetout.
      </td>
    </tr>

    <tr>
      <td>
        throttle\_window\_size
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        throttle window size for channel. if there are more than limited size messages are flying, `SendAsync` will block until messages are processed or throw exception after wait for `recv_timeout_ms`
      </td>
    </tr>

    <tr>
      <td>
        brpc\_channel\_protocol
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        BRPC client channel protocol.
      </td>
    </tr>

    <tr>
      <td>
        brpc\_channel\_connection\_type
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        BRPC client channel connection type.
      </td>
    </tr>

    <tr>
      <td>
        enable\_ssl
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        ssl options for link channel.
      </td>
    </tr>

    <tr>
      <td>
        client\_ssl\_opts
      </td>

      <td>
        [ SSLOptionsProto](#ssloptionsproto)
      </td>

      <td>
        ssl configs for channel this config is ignored if enable\_ssl == false;
      </td>
    </tr>

    <tr>
      <td>
        server\_ssl\_opts
      </td>

      <td>
        [ SSLOptionsProto](#ssloptionsproto)
      </td>

      <td>
        ssl configs for service this config is ignored if enable\_ssl == false;
      </td>
    </tr>

    <tr>
      <td>
        chunk\_parallel\_send\_size
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        chunk parallel send size for channel. if need chunked send when send message, the max paralleled send size is chunk\_parallel\_send\_size
      </td>
    </tr>

    <tr>
      <td>
        retry\_opts
      </td>

      <td>
        [ RetryOptionsProto](#retryoptionsproto)
      </td>

      <td>
        retry options
      </td>
    </tr>
  </tbody>
</table>

:target{#partyproto}

### PartyProto

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        id
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        none
      </td>
    </tr>

    <tr>
      <td>
        host
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        none
      </td>
    </tr>
  </tbody>
</table>

:target{#retryoptionsproto}

### RetryOptionsProto

Retry options.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        max\_retry
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        max retry count default 3
      </td>
    </tr>

    <tr>
      <td>
        retry\_interval\_ms
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        time between retries at first retry default 1 second
      </td>
    </tr>

    <tr>
      <td>
        retry\_interval\_incr\_ms
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        The amount of time to increase the interval between retries default 2s
      </td>
    </tr>

    <tr>
      <td>
        max\_retry\_interval\_ms
      </td>

      <td>
        [<span> uint32</span>](#uint32)
      </td>

      <td>
        The maximum interval between retries default 10s
      </td>
    </tr>

    <tr>
      <td>
        error\_codes
      </td>

      <td>
        [<span>repeated uint32</span>](#uint32)
      </td>

      <td>
        retry on these brpc error codes, if empty, retry on all codes
      </td>
    </tr>

    <tr>
      <td>
        http\_codes
      </td>

      <td>
        [<span>repeated uint32</span>](#uint32)
      </td>

      <td>
        retry on these http codes, if empty, retry on all http codes
      </td>
    </tr>

    <tr>
      <td>
        aggressive\_retry
      </td>

      <td>
        [<span> bool</span>](#bool)
      </td>

      <td>
        do aggressive retry， this means that retries will be made on additional error codes
      </td>
    </tr>
  </tbody>
</table>

:target{#ssloptionsproto}

### SSLOptionsProto

SSL options.

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        certificate\_path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Certificate file path
      </td>
    </tr>

    <tr>
      <td>
        private\_key\_path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Private key file path
      </td>
    </tr>

    <tr>
      <td>
        verify\_depth
      </td>

      <td>
        [<span> int32</span>](#int32)
      </td>

      <td>
        Set the maximum depth of the certificate chain for verification If 0, turn off the verification
      </td>
    </tr>

    <tr>
      <td>
        ca\_file\_path
      </td>

      <td>
        [<span> string</span>](#string)
      </td>

      <td>
        Set the trusted CA file to verify the peer’s certificate If empty, use the system default CA files
      </td>
    </tr>
  </tbody>
</table>

:target{#id2}

## Enums

:target{#scalar-value-types}

## Scalar Value Types

<table>
  <thead>
    <tr>
      <td>
        .proto Type
      </td>

      <td>
        Notes
      </td>

      <td>
        C++ Type
      </td>

      <td>
        Java Type
      </td>

      <td>
        Python Type
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        <div><h4 id="double" /></div><a name="double" /> double
      </td>

      <td>

      </td>

      <td>
        double
      </td>

      <td>
        double
      </td>

      <td>
        float
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="float" /></div><a name="float" /> float
      </td>

      <td>

      </td>

      <td>
        float
      </td>

      <td>
        float
      </td>

      <td>
        float
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="int32" /></div><a name="int32" /> int32
      </td>

      <td>
        Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.
      </td>

      <td>
        int32
      </td>

      <td>
        int
      </td>

      <td>
        int
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="int64" /></div><a name="int64" /> int64
      </td>

      <td>
        Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.
      </td>

      <td>
        int64
      </td>

      <td>
        long
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="uint32" /></div><a name="uint32" /> uint32
      </td>

      <td>
        Uses variable-length encoding.
      </td>

      <td>
        uint32
      </td>

      <td>
        int
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="uint64" /></div><a name="uint64" /> uint64
      </td>

      <td>
        Uses variable-length encoding.
      </td>

      <td>
        uint64
      </td>

      <td>
        long
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="sint32" /></div><a name="sint32" /> sint32
      </td>

      <td>
        Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.
      </td>

      <td>
        int32
      </td>

      <td>
        int
      </td>

      <td>
        int
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="sint64" /></div><a name="sint64" /> sint64
      </td>

      <td>
        Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.
      </td>

      <td>
        int64
      </td>

      <td>
        long
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="fixed32" /></div><a name="fixed32" /> fixed32
      </td>

      <td>
        Always four bytes. More efficient than uint32 if values are often greater than 2^28.
      </td>

      <td>
        uint32
      </td>

      <td>
        int
      </td>

      <td>
        int
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="fixed64" /></div><a name="fixed64" /> fixed64
      </td>

      <td>
        Always eight bytes. More efficient than uint64 if values are often greater than 2^56.
      </td>

      <td>
        uint64
      </td>

      <td>
        long
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="sfixed32" /></div><a name="sfixed32" /> sfixed32
      </td>

      <td>
        Always four bytes.
      </td>

      <td>
        int32
      </td>

      <td>
        int
      </td>

      <td>
        int
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="sfixed64" /></div><a name="sfixed64" /> sfixed64
      </td>

      <td>
        Always eight bytes.
      </td>

      <td>
        int64
      </td>

      <td>
        long
      </td>

      <td>
        int/long
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="bool" /></div><a name="bool" /> bool
      </td>

      <td>

      </td>

      <td>
        bool
      </td>

      <td>
        boolean
      </td>

      <td>
        boolean
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="string" /></div><a name="string" /> string
      </td>

      <td>
        A string must always contain UTF-8 encoded or 7-bit ASCII text.
      </td>

      <td>
        string
      </td>

      <td>
        String
      </td>

      <td>
        str/unicode
      </td>
    </tr>

    <tr>
      <td>
        <div><h4 id="bytes" /></div><a name="bytes" /> bytes
      </td>

      <td>
        May contain any arbitrary sequence of bytes.
      </td>

      <td>
        string
      </td>

      <td>
        ByteString
      </td>

      <td>
        str
      </td>
    </tr>
  </tbody>
</table>
