:target{#global-resource-manager}

# Global Resource Manager

:target{#overview}

## Overview

Global Resource Manager (GRM) is used to manage global data in a secure collaborative system. The global data managed by GRM includes information about parties, table schemas, SCQLEngine endpoints, and etc.

:target{#why-grm}

### Why GRM?

The SCQL system is only responsible for secure collaborative analytics, it does not own or manage data.

SCQL needs to know the following information when executing a query.

1. The schema information of the tables involved in the query includes detailed information such as the table columns and the data source type.
2. Data owner party node metadata, such as SCQLEngine endpoints.
3. Party identity management.

:target{#api}

## API

The GRM service is an HTTP service and can be implemented in any language like C++/Java/Go/Python/â€¦, where request and response are in JSON format(corresponding to their [Protocol Buffer definition](https://github.com/secretflow/scql/blob/main/api/grm.proto)).

The GRM service will be called by [client](https://github.com/secretflow/scql/blob/main/pkg/grm/stdgrm/standard_grm.go).

:target{#verifytableownership}

### /VerifyTableOwnership

When creating table, SCQL needs to verify whether the user holding the token owns the table specified by TID

:target{#request}

#### Request

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        tid
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        Table identifier provided by user when create table, read [<span>Create table</span>](scql_manual.mdx#create-table) for more information
      </td>
    </tr>

    <tr>
      <td>
        token
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The token used to authenticate the user
      </td>
    </tr>
  </tbody>
</table>

:target{#response}

#### Response

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        status
      </td>

      <td>
        [Status](#status)
      </td>

      <td>
        Y
      </td>

      <td>
        Status of response
      </td>
    </tr>

    <tr>
      <td>
        is\_owner
      </td>

      <td>
        bool
      </td>

      <td>
        Y
      </td>

      <td>
        True: user is the owner of the table
      </td>
    </tr>
  </tbody>
</table>

:target{#status}

##### Status

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        code
      </td>

      <td>
        int32
      </td>

      <td>
        Y
      </td>

      <td>
        The status code, 0 means success
      </td>
    </tr>

    <tr>
      <td>
        Messages
      </td>

      <td>
        string
      </td>

      <td>
        N
      </td>

      <td>
        Message for recording the error information.
      </td>
    </tr>

    <tr>
      <td>
        details
      </td>

      <td>
        protobuf.Any list
      </td>

      <td>
        N
      </td>

      <td>
        A list of messages for error details
      </td>
    </tr>
  </tbody>
</table>

:target{#example}

#### Example

Request

```javascript
{
    "tid": "some_tid",
    "token": "some_token"
}
```

Response

```javascript
{
    "status": {
        "code": 0,
        "message": "",
        "details": []
    },
    "is_owner": true
}
```

:target{#gettablemeta}

### /GetTableMeta

During creating table, after ensuring the ownership, SCQL needs to Get table schema from grm service.

:target{#id1}

#### Request

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        tid
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        Unique table identifier
      </td>
    </tr>

    <tr>
      <td>
        request\_party
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The party code of request issuer
      </td>
    </tr>

    <tr>
      <td>
        token
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The token used to authenticate the user
      </td>
    </tr>
  </tbody>
</table>

:target{#id2}

#### Response

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        status
      </td>

      <td>
        [Status](#status)
      </td>

      <td>
        Y
      </td>

      <td>
        The status of response
      </td>
    </tr>

    <tr>
      <td>
        schema
      </td>

      <td>
        [TableSchema](#tableschema)
      </td>

      <td>
        Y
      </td>

      <td>
        The schema of the table
      </td>
    </tr>
  </tbody>
</table>

:target{#tableschema}

##### TableSchema

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        db\_name
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The name of the database that the table belongs to
      </td>
    </tr>

    <tr>
      <td>
        table\_name
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The name of the table
      </td>
    </tr>

    <tr>
      <td>
        columns
      </td>

      <td>
        [ColumnDesc](#columndesc) list
      </td>

      <td>
        Y
      </td>

      <td>
        The column information in the table
      </td>
    </tr>

    <tr>
      <td>
        db\_type
      </td>

      <td>
        [DataSourceKind](#datasourcekind)
      </td>

      <td>
        N
      </td>

      <td>
        The type of backend data source. Supported values in [DataSourceKind](#datasourcekind)
      </td>
    </tr>
  </tbody>
</table>

:target{#columndesc}

###### ColumnDesc

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        name
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The column name
      </td>
    </tr>

    <tr>
      <td>
        type
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        The type of column value
      </td>
    </tr>

    <tr>
      <td>
        description
      </td>

      <td>
        string
      </td>

      <td>
        N
      </td>

      <td>
        The description of the column
      </td>
    </tr>
  </tbody>
</table>

:target{#datasourcekind}

###### DataSourceKind

<table>
  <thead>
    <tr>
      <td>
        Value
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        UNKNOWN
      </td>

      <td>
        Default MySQL
      </td>
    </tr>

    <tr>
      <td>
        MYSQL
      </td>

      <td>
        MySQL backend
      </td>
    </tr>

    <tr>
      <td>
        SQLITE
      </td>

      <td>
        SQLite backend
      </td>
    </tr>

    <tr>
      <td>
        POSTGRESQL
      </td>

      <td>
        Postgres backend
      </td>
    </tr>

    <tr>
      <td>
        CSVDB
      </td>

      <td>
        CSV backend
      </td>
    </tr>
  </tbody>
</table>

:target{#id3}

#### Example

request

```javascript
{
    "tid": "1"
    "request_party": "some_party",
    "token": "some_token",
}
```

response

```javascript
{
    "status": {
        "code": 0,
        "message": "",
        "details": []
    },
    "schema" {
        "db_name": "some_da_name",
        "db_type": 1,
        "table_name": "some_table_name"
        "columns": [
            {
                "name": "col1",
                "type": "long"
            },
            {
                "name": "col2",
                "type": "string"
            }
        ]
    }
}
```

:target{#getengines}

### /GetEngines

During executing the DQL submitted by the user holding the token, SCQL needs to get the SCQLEngine information of the relevant parties.

:target{#id4}

#### Request

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        party\_codes
      </td>

      <td>
        string list
      </td>

      <td>
        Y
      </td>

      <td>
        Parties whose SCQLEngine info need to be obtained
      </td>
    </tr>

    <tr>
      <td>
        token
      </td>

      <td>
        string
      </td>

      <td>
        Y
      </td>

      <td>
        Token used to authenticate the user
      </td>
    </tr>
  </tbody>
</table>

:target{#id5}

#### Response

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        status
      </td>

      <td>
        [Status](#status)
      </td>

      <td>
        Y
      </td>

      <td>
        The status of response
      </td>
    </tr>

    <tr>
      <td>
        engine\_infos
      </td>

      <td>
        [EngineInfo](#engineinfo) list
      </td>

      <td>
        Y
      </td>

      <td>
        engine\_infos\[i] is SCQLEngine info for party request.party\_codes\[i]
      </td>
    </tr>
  </tbody>
</table>

:target{#engineinfo}

##### EngineInfo

<table>
  <thead>
    <tr>
      <td>
        Field
      </td>

      <td>
        Type
      </td>

      <td>
        Required
      </td>

      <td>
        Description
      </td>
    </tr>
  </thead>

  <tbody>
    <tr>
      <td>
        endpoints
      </td>

      <td>
        string list
      </td>

      <td>
        Y
      </td>

      <td>
        The url of SCQLEngine
      </td>
    </tr>

    <tr>
      <td>
        credential
      </td>

      <td>
        string list
      </td>

      <td>
        Y
      </td>

      <td>
        Credential used for SCQLEngine to authenticate SCDB
      </td>
    </tr>
  </tbody>
</table>

:target{#id6}

#### Example

Request

```javascript
{
    "party_codes": ["party1", "party2"],
    "token": "some_token"
}
```

Response

```javascript
{
    "status": {
        "code": 0,
        "message": "",
        "details": []
    },
   "engine_infos": [
        {
            "endpoints": ["party1_url"],
            "credential": ["party1_credential"]
        },
        {
            "endpoints": ["party2_url"],
            "credential": ["party2_credential"]
        }
   ]
}
```
