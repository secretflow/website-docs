:target{#scql-operators-specification}

# SCQL 算子规范

这是 SCQL 算子的规范 (不是内核库),包括算子签名和语义

:target{#op-list}

## 算子列表

:target{#add}

### `Add`

Out = Left `Add` Right

输入：

1. <del id="id2">\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#broadcastto}

### `BroadcastTo`

将输入的 tensor <cite>In</cite> 广播转变为与 ShapeRefTensor 相同的 shape。例：

```Python
In = [1]
ShapeRefTensor = [a, b, c]
# ShapeRefTensor's shape is (3, 1), broadcast In to shape (3, 1)
Out = BroadcastTo(In, ShapeRefTensor) = [1, 1, 1]
```

输入：

1. <del>\`</del>In\`(可变参数, T)：输入 tensor
2. <del>\`</del>ShapeRefTensor\`(single, T1)：Shape reference tensor

输出：

1. <del>\`</del>Out\`(可变参数, T2)： tensor 结果

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#concat}

### `Concat`

定义：给定一组 tensor (可变参数)，其中 tensor 的 shape 必须相同，(除了轴之外)，将它们沿着指定的轴拼接起来。例如：

```python
In = { {1, 2}, {2, 3, 4}, {3, 4, 5, 6} }
Out = {1, 2, 2, 3, 4, 3, 4, 5, 6}
```

输入：

1. <del>\`</del>In\`(可变参数, T)：要连接的 tensor 。

输出：

1. <del>\`</del>Out\`(single, T)：整合 tensor 。

<strong>属性：</strong>

1. <cite>axis</cite>: Int64. 要连接的维度。

<strong>默认属性值:</strong>

1. `axis`: 0

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#constant}

### `Constant`

定义：根据 Attributes 生成常量。例如：

```python
scalar = [{"a", "b", "c"}]
to_status = 0
Out = [{"a", "b", "c"}]
```

输入：

无输入参数。

输出：

1. <del>\`</del>Out\`(single, T)：从常量输出 tensor 。

<strong>属性：</strong>

1. <cite>scalar</cite>：标量属性。
2. <cite>to\_status</cite>：int64. to status, 0：to private, 1：to public.

<strong>默认属性值:</strong>

1. `to_status`: 0

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>：公共，私有。

:target{#copy}

### `Copy`

定义：将源 tensor 复制到新的目前 tensor 中。

输入：

1. <del>\`</del>In\`(single, T1)：源 tensor 。

输出：

1. <del>\`</del>Out\`(single, T1)：目标 tensor 。

<strong>属性：</strong>

1. <cite>input\_party\_codes</cite>：输入 tensor In 所属方。
2. <cite>output\_party\_codes</cite>：输出 tensor Out 所属方。

TensorStatus(ShareType) Constraints：

1. <cite>T1</cite>: 私有

:target{#div}

### `Div`

Out = Left `Div` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#dumpfile}

### `DumpFile`

定义：将输入的 tensor 存储到文件中。注意：此操作将更改会话中受影响的行。

输入：

1. <del>\`</del>In\`(可变参数, T)：要存储的 tensor。

输出：

1. <del>\`</del>Out\`(可变参数, T)： 已被转储的 tensor。

<strong>属性：</strong>

1. <cite>file\_path</cite>：字符串。用于转储 tensor 的绝对文件路径。
2. deliminator：字符串。列分隔符，例如逗号。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#equal}

### `Equal`

Out = Left `Equal` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#filter}

### `Filter`

给定一个boolean tensorsFilter (其 shape 为\[M])，以及一些 tensor In (可变参数，每个 tensor 的shape必须为\[M])。对于i在\[0, M-1]的范围内，仅当Filter\[i]为真时，保留In tensor 的元素，并输出过滤结果 tensor Out (可变参数)。例:

```python
Filter = {True, False, False, True, False}
In = {a, b, c, d, e}
Out = {a, d}
```

输入：

1. <del>\`</del>Filter\`(single, T1)：Filter tensor 。
2. <del>\`</del>In\`(可变参数, T)：待过滤的 tensor 。

输出：

1. <del>\`</del>Out\`(可变参数, T)：输出 tensor 。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态
2. <cite>T1</cite>: 公开，私有

:target{#filterbyindex}

### `FilterByIndex`

定义：按行索引筛选。例：

```python
RowsIndexFilter = {3,1,0}
Data = [{"a", "b", "c", "d"}, {0, 1, 2, 3}]
Out = [{"d", "b", "a"}, {3, 1, 0}]
```

输入：

1. RowsIndexFilter (single, T)：行索引筛选器向量(shape \[K]\[1])
2. <del>\`</del>Data\`(可变参数, T)：输入数据 tensor (shape \[M]\[N])。

输出：

1. <del>\`</del>Out\`(可变参数, T)：输出数据 tensor (shape \[X]\[N])。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#greater}

### `Greater`

Out = Left `Greater` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#greaterequal}

### `GreaterEqual`

Out = Left `GreaterEqual` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#group}

### `Group`

定义:为每个输入元素分配一个组id(从0开始)。定义：

```python
Key = [{"a", "c", "a", "d"}, {0, 2, 0, 3}]
GroupId = {0, 1, 0, 2}
GroupNum = {3}
```

输入：

1. <del>\`</del>Key\`(可变参数, T): input key tensors。

输出：

1. <del>\`</del>GroupId\`(single, T): group id vector。
2. <del>\`</del>GroupNum\`(single, T): number of groups vector

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupavg}

### `GroupAvg`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{1, 2, 4}, {8, 7, 5}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupcount}

### `GroupCount`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{2, 2, 1}, {2, 2, 1}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupcountdistinct}

### `GroupCountDistinct`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{2, 2, 1}, {2, 2, 1}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupfirstof}

### `GroupFirstOf`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{0, 1, 4}, {9, 8, 5}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupmax}

### `GroupMax`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{2, 3, 4}, {9, 8, 5}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupmin}

### `GroupMin`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{0, 1, 4}, {7, 6, 5}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#groupsum}

### `GroupSum`

定义：为每个组聚合 <cite>Data</cite>。例子:

```python
GroupId = {0, 1, 0, 1, 2}
GroupNum = {3}
In = [{0, 1, 2, 3, 4}, {9, 8, 7, 6, 5}]
Out = [{2, 4, 4}, {16, 14, 5}]
```

输入：

1. <del>\`</del>GroupId\`(single, T): 输入组向量的id。
2. <del>\`</del>GroupNum\`(single, T): 输入组向量的个数。
3. <del>\`</del>In\`(可变参数, T): 输入数据 tensor

输出：

1. <del>\`</del>Out\`(可变参数, T):输出数据 tensors (shape \[K]\[1], K 等于组的个数), Out\[i] 是第 i 组聚合的结果。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#in}

### `In`

定义：给定一个名为 Left 的输入 tensor (其 shape 为 \[M]) 和另一个名为 Right 的 Tensor (其 shape 为 \[N])，检查 Left 的元素是否存在于右的元素中，并输出一名为 Out 的布尔类型的 tensor (其 shape 为 \[M])。左和右必须是相同的类型。例：

```python
Left = {a, b, c, d}
Right = {b, d, e, f, g, h}
Out = {False, True, False, True}
```

输入：

1. <del>\`</del>Left\`(single, T): 第一个操作数。
2. <del>\`</del>Right\`(single, T1): 第二个操作数。

输出：

1. <del>\`</del>Out\`(single, T): 输出 tensor 。

<strong>属性：</strong>

1. <cite>algorithm</cite>：Int64类型， 用于 IN 操作的算法，1表示使用PSI算法。
2. <cite>input\_party\_codes</cite>：参与In操作的输入，其所属的参与方的列表。如果采用 PSI 算法，则需要此属性。
3. <cite>reveal\_to</cite>：可以看到结果的参与方。如果采用 PSI 算法，则需要此属性。

<strong>默认属性值:</strong>

1. `algorithm`: 0

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有
2. <cite>T1</cite>: 私有

:target{#intdiv}

### `IntDiv`

Out = Left `IntDiv` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#join}

### `Join`

定义：基于 EQ-Join 创建连接索引，返回原始输入中结果对应的行索引。例：

```python
// inner join example
Left = {4,4,3,2,1} // shape:[M=5]
Right = {1,3,4,5} // shape: [N=4]
LeftJoinIndex = {4,2,0,1}  // shape:[K=4], rows after applied filter eq-join-list={1,3,4,4}
RightJoinIndex = {0,1,2,2} // shape:[K=4], rows after applied filter eq-join-list={1,3,4,4}
```

输入：

1. <del>\`</del>Left\`(single, T1): Left vector
2. <del>\`</del>Right\`(single, T1): Right vector

输出：

1. <del>\`</del>LeftJoinIndex\`(single, T2)：参与join操作的左侧向量的行索引。
2. <del>\`</del>RightJoinIndex\`(single, T2)：参与join操作的右向量的行索引。

<strong>属性：</strong>

1. <cite>input\_party\_codes</cite>：输入所属的各方列表（\[PartyCodeLeft, PartyCodeRight]）。
2. `join_type`: Int64. 0: inner join;

<strong>默认属性值:</strong>

1. `join_type`: 0

TensorStatus(ShareType) Constraints：

1. <cite>T1</cite>: 私有
2. `T2`: private

:target{#less}

### `Less`

Out = Left `Less` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#lessequal}

### `LessEqual`

Out = Left `LessEqual` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#logicaland}

### `LogicalAnd`

Out = Left `LogicalAnd` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#logicalor}

### `LogicalOr`

Out = Left `LogicalOr` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#makeprivate}

### `MakePrivate`

将 tensor 从共享或私有状态转换为公开状态。

输入：

1. <del>\`</del>In\`(可变参数, T1)：输入 tensor 。

输出：

1. <del>\`</del>Out\`(可变参数, T2)：输出 tensor 。

<strong>属性：</strong>

1. <cite>reveal\_to</cite>：一个包含可查看私有数据的方的列表。如果只向一方透露，那么另一方也需要运行该操作，但不会有结果。只有被指定为 reveal\_to 的一方才能获取结果。

TensorStatus(ShareType) Constraints：

1. `T1`: secret,public
2. `T2`: private

:target{#makepublic}

### `MakePublic`

将 tensor 从私有状态转变为共享状态。

输入：

1. <del>\`</del>In\`(可变参数, T1)：输入 tensor 。

输出：

1. <del>\`</del>Out\`(可变参数, T2)：输出 tensor 。

TensorStatus(ShareType) Constraints：

1. <cite>T1</cite>: 私有,密态
2. <cite>T2</cite>: 公开

:target{#makeshare}

### `MakeShare`

将 tensor 从私有状态转变为共享状态。

输入：

1. <del>\`</del>In\`(可变参数, T1)：输入 tensor 。

输出：

1. <del>\`</del>Out\`(可变参数, T2)：输出 tensor 。

TensorStatus(ShareType) Constraints：

1. <cite>T1</cite>: 私有
2. <cite>T2</cite>: 密态

:target{#minus}

### `Minus`

Out = Left `Minus` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#mod}

### `Mod`

Out = Left `Mod` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#mul}

### `Mul`

Out = Left `Mul` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#not}

### `Not`

Out = Not In

输入：

1. `In`(single, T): Input tensor.

输出：

1. `Out`(single, T): Output tensor.

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态

:target{#notequal}

### `NotEqual`

Out = Left `NotEqual` Right

输入：

1. <del>\`</del>Left\`(可变参数, T): 第一个操作数.
2. <del>\`</del>Right\`(可变参数, T1): 第二个操作数。

输出：

1. Out\`(可变参数, T2): 输出：

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 公开，私有，密态
3. <cite>T2</cite>: 公开，私有

:target{#obliviousgroupavg}

### `ObliviousGroupAvg`

定义: 根据 group mask 来对输入进行分组求和。

```python
Group = {1, 0, 0, 1, 1}
In = [{1, 3, 2, 4, 0}, {9, 8, 7, 6, 5}]
Out = [{1, 3, 2.5, 3, 0}, {9, 8, 7.5, 7, 5}]
```

输入：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。
2. <del>\`</del>In\`(可变参数, T): 需要聚合的值。

输出：

1. <del>\`</del>Out\`(可变参数, T): 部分聚合的值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#obliviousgroupcount}

### `ObliviousGroupCount`

定义: 根据 group mask 来对输入进行分组求和。

```python
Group = {1, 0, 0, 1, 1}
In = [{1, 3, 2, 4, 0}, {9, 8, 7, 6, 5}]
Out = [{1, 1, 2, 3, 1}, {1, 1, 2, 3, 1}]
```

输入：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。
2. <del>\`</del>In\`(可变参数, T): 需要聚合的值。

输出：

1. <del>\`</del>Out\`(可变参数, T): 部分聚合的值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#obliviousgroupmark}

### `ObliviousGroupMark`

定义：根据输入的 key 生成一个 group ，group 的计算规则为 Group\[i] = not\_eq(Key\[i+1], Key\[i])。例：

```python
Key = [{0, 0, 0, 1}, {0, 1, 1, 1}]
Group = {1, 0, 1, 1}

Key = [{0, 0, 1, 2, 2}]
Group = {0, 1, 1, 0, 1}
```

输入：

1. <del>\`</del>Key\`(可变参数, T): 排序过的 group key。

输出：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#obliviousgroupmax}

### `ObliviousGroupMax`

定义: 根据 group mask 来对输入进行分组求和。

```python
Group = {1, 0, 0, 1, 1}
In = [{1, 3, 2, 4, 0}, {9, 8, 7, 6, 5}]
Out = [{1, 3, 3, 4, 0}, {9, 8, 8, 8, 5}]
```

输入：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。
2. <del>\`</del>In\`(可变参数, T): 需要聚合的值。

输出：

1. <del>\`</del>Out\`(可变参数, T): 部分聚合的值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#obliviousgroupmin}

### `ObliviousGroupMin`

定义: 根据 group mask 来对输入进行分组求和。

```python
Group = {1, 0, 0, 1, 1}
In = [{1, 3, 2, 4, 0}, {9, 8, 7, 6, 5}]
Out = [{1, 3, 2, 2, 0}, {9, 8, 7, 6, 5}]
```

输入：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。
2. <del>\`</del>In\`(可变参数, T): 需要聚合的值。

输出：

1. <del>\`</del>Out\`(可变参数, T): 部分聚合的值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#obliviousgroupsum}

### `ObliviousGroupSum`

定义: 根据 group mask 来对输入进行分组求和。

```python
Group = {1, 0, 0, 1, 1}
In = [{1, 3, 2, 4, 0}, {9, 8, 7, 6, 5}]
Out = [{1, 3, 5, 9, 0}, {9, 8, 15, 21, 5}]
```

输入：

1. <del>\`</del>Group\`(single, T): 生成的 groupMark (shape \[M]\[1])，其中1表示是该分组中的最后一元素，0则表示不是最后一个元素。
2. <del>\`</del>In\`(可变参数, T): 需要聚合的值。

输出：

1. <del>\`</del>Out\`(可变参数, T): 部分聚合的值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#publish}

### `Publish`

该算子披露 DAG 结果。

输入：

1. <del>\`</del>In\`(可变参数, T1)：要披露的 Tensors。

输出：

1. <del>\`</del>Out\`(可变参数, T2)：披露 publish op tensors 结果 。Tensors 位于 TensorOption VALUE 中。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#reduceavg}

### `ReduceAvg`

定义：给定一个输入 tensor ，返回输入 tensor 元素的平均值。例：

```python
In = {1, 2, 3, 4, 5}
Out = {3}

In = {1, 2, 3, 4}
Out = {2.5}
```

输入：

1. <del>\`</del>In\`(single, T)：需要求平均的 tensor。

输出：

1. <del>\`</del>Out\`(single, T)：平均值 tensor 。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#reducemax}

### `ReduceMax`

定义：给定一个输入 tensor ，返回输入 tensor 元素的最大值。例：

```python
In = {1, 2, 3, 4, 5, 6}
Out = {6}
```

输入：

1. <del>\`</del>In\`(single, T): 需要计算最大值的 tensor。

输出：

1. <del>\`</del>Out\`(single, T)：最大值的 tensor。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#reducemin}

### `ReduceMin`

定义：给定一个输入 tensor ，返回输入 tensor 元素的最小值。例：

```python
In = {1, 2, 3, 4, 5, 6}
Out = {1}
```

输入：

1. <del>\`</del>In\`(single, T)：需要计算最小值的 tensor。

输出：

1. <del>\`</del>Out\`(single, T)：最小值的tensor。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#reducesum}

### `ReduceSum`

定义：给定一个输入 tensor ，返回输入 tensor 元素的总和。例：

```python
In = {1, 2, 3, 4, 5, 6}
Out = {21}
```

输入：

1. <del>\`</del>In\`(single, T)：要求和的 tensor 。

输出：

1. <del>\`</del>Out\`(single, T)： tensor 的和。

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#runsql}

### `RunSQL`

运行 SQL 语句并返回私有状态下的 tensors 列表

输入：

无输入参数。

输出：

1. Out\`(可变参数, T): SQL 语句的结果 tensors。

<strong>属性：</strong>

1. <cite>sql</cite>：SQL 语句
2. <cite>table\_refs</cite>：query中引用的表

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#shape}

### `Shape`

定义：给定 tensor ，返回每个 tensor 的 shapes，Axis从 0 开始。如果设置了 Axis，则返回每个 shapes 的维度。如果未设置 Axis (默认为 -1)，则返回 shapes 。例

```python
In = { {1, 2}, {2, 3}, {4, 3, 3} } # {1, 2} here is a column vector
Out = { {2, 1}, {2, 1}, {3, 1} }
```

输入：

1. <del>\`</del>In\`(可变参数, T1)：要披露的 Tensors。

输出：

1. <del>\`</del>Out\`(可变参数, T1): 输出 Shape

<strong>属性：</strong>

1. <cite>axis</cite>: Int64. shape 的特定维度。

<strong>默认属性值:</strong>

1. `axis`: -1

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 公开，私有，密态
2. <cite>T1</cite>: 私有

:target{#shuffle}

### `Shuffle`

定义：Shuffle <cite>In</cite>。例：

```python
In = [{1, 2, 3, 4}, {9, 8, 7, 6}]
Out = [{4, 3, 2, 1}, {6, 7, 8, 9}]
```

输入：

1. <del>\`</del>In\`(可变参数, T)：输入值。

输出：

1. <del>\`</del>Out\`(可变参数, T)：输出值。

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有

:target{#sort}

### `Sort`

定义: 使用 <cite>Key</cite> 对输入内容进行排序。例：

```python
Key = {3, 1, 2, 4}
In = [{3, 1, 2, 4}, {1, 2, 3, 4}, {9, 8, 7, 6}]
Out = [{1, 2, 3, 4}, {2, 3, 1, 4}, {8, 7, 9, 6}]
```

输入：

1. <del>\`</del>Key\`(可变参数, T): 排序键
2. <del>\`</del>In\`(可变参数, T): 所需排序的值。

输出：

1. <del>\`</del>Out\`(可变参数, T):排序后的结果。

<strong>属性：</strong>

1. <cite>reverse</cite>: Bool, 如果为 True, 则 tensor 按照从大到小的顺序排列。

<strong>默认属性值:</strong>

1. `reverse`: false

TensorStatus(ShareType) Constraints：

1. <del>\`</del>T\`私有，密态

:target{#unique}

### `Unique`

定义：Key tensor 的唯一性。例：

```python
Key = {"a", "b", "a", "d"}
UniqueKey = {"a", "b", "d"}
```

输入：

1. <del>\`</del>Key\`(single, T): 输入 Key tensor(shape \[M]\[1])

输出：

1. <del>\`</del>UniqueKey\`(single, T): 输出唯一 key tensor(shape \[K]\[1])

TensorStatus(ShareType) Constraints：

1. <cite>T</cite>: 私有
